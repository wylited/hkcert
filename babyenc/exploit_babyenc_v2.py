#!/usr/bin/env python3
"""
BabyEnc Multi-Exploit Script for HKCERT AWD
Supports multiple attack vectors with fallback

Exploits:
1. Nonce Reuse (primary) - works on unpatched binaries
2. XOR with Known Plaintext - if we can guess part of the flag format
"""
import os
os.environ['PWNLIB_NOTERM'] = '1'

import sys
import argparse
import time
from pwn import *
from awd_lib import (
    chal, submit, get_targets, get_our_ip
)

context.log_level = 'error'

# Configure challenge
chal(creds_file="babyenc.xls")

PORT = 1000

class BabyEncExploit:
    def __init__(self, ip, port=PORT, timeout=10):
        self.ip = ip
        self.port = port
        self.timeout = timeout
        self.io = None
        
    def connect(self):
        self.io = remote(self.ip, self.port, timeout=self.timeout)
        return self.io
        
    def close(self):
        if self.io:
            self.io.close()
            self.io = None
    
    def send_cmd(self, cmd, *args):
        self.io.recvuntil(b'> ')
        self.io.sendline(str(cmd).encode())
        for arg in args:
            self.io.recvuntil(b': ')
            if isinstance(arg, bytes):
                self.io.sendline(arg)
            else:
                self.io.sendline(str(arg).encode())
    
    def get_flag_info(self):
        """Get flag cipher and length"""
        self.send_cmd(7)  # list notes
        resp = self.io.recvuntil(b'> ')
        
        flag_len = None
        if b'len=' in resp:
            start = resp.find(b'len=') + 4
            end = resp.find(b'\n', start)
            flag_len = int(resp[start:end].strip())
        
        # Get encrypted flag via show note (option 3) index 0
        self.send_cmd(3, 0)
        resp = self.io.recvuntil(b'> ')
        
        flag_cipher = None
        if b'system note (enc): ' in resp:
            start = resp.find(b'system note (enc): ') + len(b'system note (enc): ')
            end = resp.find(b'\n', start)
            flag_cipher = bytes.fromhex(resp[start:end].strip().decode())
        
        return flag_cipher, flag_len
    
    def create_note(self, index, data):
        """Create a note with given data (as bytes)"""
        self.send_cmd(1, index, len(data), data.hex().encode())
    
    def encrypt_note(self, index):
        """Encrypt a note, return ciphertext"""
        self.send_cmd(4, index)
        resp = self.io.recvuntil(b'> ')
        if b'note cipher(hex): ' in resp:
            start = resp.find(b'note cipher(hex): ') + len(b'note cipher(hex): ')
            end = resp.find(b'\n', start)
            return bytes.fromhex(resp[start:end].strip().decode())
        return None
    
    def decrypt_note(self, index):
        """Decrypt a note"""
        self.send_cmd(5, index)
        self.io.recvuntil(b'> ')
    
    def delete_note(self, index):
        """Delete a note"""
        self.send_cmd(6, index)
        self.io.recvuntil(b'> ')
    
    # ===================== EXPLOIT 1: Nonce Reuse =====================
    def exploit_nonce_reuse(self):
        """
        Primary exploit: Nonce reuse attack
        
        Flag is encrypted with nonce0 at startup.
        Toggle starts at 1, so first encrypt uses nonce1.
        Decrypt sets toggle = note_index.
        
        Attack:
        1. Create note at index 2 with zeros
        2. Encrypt (uses nonce1)
        3. Decrypt (sets toggle = 2, which is even)
        4. Create new note with zeros
        5. Encrypt (now uses nonce0!)
        6. XOR keystream with flag cipher to get plaintext
        """
        try:
            self.connect()
            flag_cipher, flag_len = self.get_flag_info()
            
            if not flag_cipher:
                return None, "Could not get flag cipher"
            
            # Create note at even index (2) with zeros matching flag length
            zeros = b'\x00' * len(flag_cipher)
            self.create_note(2, zeros)
            
            # Encrypt to use nonce1
            self.encrypt_note(2)
            
            # Decrypt to set toggle = 2 (even)
            self.decrypt_note(2)
            
            # Clean up and create new note
            self.delete_note(2)
            self.create_note(3, zeros)
            
            # Encrypt - this uses nonce0 (same as flag)
            keystream = self.encrypt_note(3)
            
            if keystream:
                # XOR to recover flag
                flag = bytes(a ^ b for a, b in zip(flag_cipher, keystream))
                return flag.decode('utf-8', errors='replace'), None
            
            return None, "Failed to get keystream"
        except Exception as e:
            return None, str(e)
        finally:
            self.close()
    
    # ===================== EXPLOIT 2: Known Plaintext =====================
    def exploit_known_plaintext(self, known_prefix=b'flag{'):
        """
        Backup exploit: Known plaintext attack
        
        If we know part of the flag format, we can partially decrypt.
        Not useful for full flag but can verify format.
        """
        try:
            self.connect()
            flag_cipher, flag_len = self.get_flag_info()
            
            if not flag_cipher:
                return None, "Could not get flag cipher"
            
            # XOR known prefix with cipher
            partial = bytes(a ^ b for a, b in zip(flag_cipher, known_prefix))
            
            return partial.hex(), None
        except Exception as e:
            return None, str(e)
        finally:
            self.close()
    
    # ===================== EXPLOIT 3: Probe for patches =====================
    def probe_patches(self):
        """
        Check which patches are applied
        Returns dict of vulnerability status
        """
        patches = {
            'nonce_reuse': True,  # Assume vulnerable
            'vault_leak': True,
            'key_overwrite': True
        }
        
        try:
            self.connect()
            
            # Test nonce reuse: encrypt twice after decrypt at even index
            zeros = b'\x00' * 8
            self.create_note(2, zeros)
            cipher1 = self.encrypt_note(2)
            self.decrypt_note(2)
            
            self.delete_note(2)
            self.create_note(3, zeros)
            cipher2 = self.encrypt_note(3)
            
            # If both ciphers are the same, nonce reuse is PATCHED
            # (both used nonce1)
            if cipher1 == cipher2:
                patches['nonce_reuse'] = False  # Patched!
            
            return patches, None
        except Exception as e:
            return None, str(e)
        finally:
            self.close()
    
    # ===================== Main exploit runner =====================
    def run_all_exploits(self):
        """Try all exploits in order of reliability"""
        
        # First probe for patches
        patches, err = self.probe_patches()
        if err:
            return None, f"Probe failed: {err}"
        
        # Try nonce reuse if not patched
        if patches.get('nonce_reuse', False):
            flag, err = self.exploit_nonce_reuse()
            if flag and flag.startswith('flag{'):
                return flag, "nonce_reuse"
        
        return None, "All exploits failed or patched"


def exploit(ip, port=PORT):
    """Main exploit entry point for AWD framework"""
    exp = BabyEncExploit(ip, port)
    flag, method = exp.run_all_exploits()
    return flag


def main():
    parser = argparse.ArgumentParser(description='BabyEnc Multi-Exploit')
    parser.add_argument('--target', '-t', help='Single target IP')
    parser.add_argument('--port', '-p', type=int, default=PORT, help='Port')
    parser.add_argument('--loop', action='store_true', help='Loop continuously')
    parser.add_argument('--scan', action='store_true', help='Scan targets for patches')
    parser.add_argument('--creds', default='babyenc.xls', help='Credentials file')
    args = parser.parse_args()
    
    our_ip = get_our_ip(args.creds)
    targets = get_targets(args.creds)
    
    print(f"[*] Our IP: {our_ip}")
    
    if args.target:
        targets = [args.target]
    
    print(f"[*] Targets: {len(targets)}")
    
    if args.scan:
        print("\n[*] Scanning for patches...")
        for ip in targets:
            exp = BabyEncExploit(ip, args.port)
            patches, err = exp.probe_patches()
            if err:
                print(f"  {ip}: ERROR - {err}")
            else:
                nonce = "VULN" if patches['nonce_reuse'] else "PATCHED"
                print(f"  {ip}: nonce_reuse={nonce}")
        return
    
    while True:
        success = 0
        failed = 0
        
        for ip in targets:
            print(f"[*] Attacking {ip}:{args.port}...")
            try:
                flag = exploit(ip, args.port)
                if flag and flag.startswith('flag{'):
                    print(f"[+] Got flag: {flag}")
                    result = submit(flag)
                    print(f"[+] Submitted ({result})")
                    success += 1
                else:
                    print(f"[-] Failed: {flag}")
                    failed += 1
            except Exception as e:
                print(f"[-] Error: {e}")
                failed += 1
        
        print(f"\n[*] Done: {success} success, {failed} failed")
        
        if not args.loop:
            break
        
        print("[*] Sleeping 60s...")
        time.sleep(60)


if __name__ == '__main__':
    main()
