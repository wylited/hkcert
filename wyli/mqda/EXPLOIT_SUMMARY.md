# MQDA Exploit Summary

## Overview

MQDA is a custom 32-bit VM running on a 64-bit host. The challenge involves exploiting this VM to read a flag.

## Confirmed Vulnerabilities

### 1. Use-After-Free via Cleanup Mechanism ✅ CRITICAL

The VM has a cleanup mechanism that runs after EVERY instruction:
1. Iterates through all tracked pages
2. If a page's data bytes (4-0x103) are ALL ZEROS, it frees the page
3. Page table entries are cleared

**Exploitation:**
```python
# 1. Allocate a page
write_dword(0x20000, 0x11111111)

# 2. Zero all 256 data bytes → triggers free in cleanup
for offset in range(0, 256, 4):
    write_dword(0x20000 + offset, 0)

# 3. Write controlled data to same address → reallocates (may reuse freed chunk)
write_dword(0x20000, payload)

# 4. Jump to that address → execute controlled code!
jmp(0x20000)
```

### 2. Bit-by-Bit Oracle ✅
We can determine any bit of any 32-bit value in VM memory by:
1. Writing data to a VM address
2. Reading it back via POP
3. Isolating a specific bit using SHL/SHR
4. Comparing to expected value with CMP
5. Using JNE + HLT/ILLEGAL to signal result

**Key insight:** JNE is INVERTED from x86 - it jumps when values ARE equal!

### 3. Arbitrary VM Memory Read/Write ✅
- **Write:** Use PUSH at any SP address
- **Read:** Use POP from any SP address
- Full 32-bit address space accessible

### 4. OOB Read/Write (Limited) ⚠️
- PUSH at SP offset 0xFF writes to page[0x103..0x106]
- This is WITHIN malloc's usable area (0x108 bytes)
- NOT directly exploitable for heap corruption

## Attack Summary

### Current Capabilities
| Attack | Status | Impact |
|--------|--------|--------|
| Use-After-Free | ✅ CONFIRMED | Execute controlled VM code from freed+reallocated page |
| Bit-by-bit Oracle | ✅ WORKING | Leak any byte from VM memory |
| Arbitrary VM R/W | ✅ WORKING | Read/write any VM address |
| RCE (native code) | ⏳ Needs more work | Potential via tcache poisoning on UAF |

### For Flag Exfiltration
1. **If flag in VM memory:** Use oracle to leak byte-by-byte (32 connections per byte)
2. **If flag in file:** Need native RCE via heap exploitation

## VM Architecture

```
vm_state (0x50 bytes):
  +0x00: page_table*     (8 bytes)
  +0x08: IP              (4 bytes)
  +0x0C: flags           (1 byte)
  +0x10: regs[16]        (64 bytes, r0-r15)
  +0x4C: SP (r15)        (4 bytes)

Page (260 bytes):
  +0x00: VM address header (4 bytes)
  +0x04: data (256 bytes)
  [+0x104-0x107: malloc padding, usable]
```

## Instruction Encodings

| Opcode | Mode | Encoding | Description |
|--------|------|----------|-------------|
| HLT | 0 | `00` | Halt (exit code 1) |
| MOV | 2 | `41 REG IMM32` | reg = imm32 |
| PUSH | 0 | `02 REG` | [SP+4] = reg; SP -= 4 |
| POP | 0 | `03 REG` | reg = [SP+4]; SP += 4 |
| SHL | 2 | `4B REG IMM32` | reg <<= imm32 |
| SHR | 2 | `4C REG IMM32` | reg >>= imm32 |
| CMP | 1 | `2D REG1 REG2` | compare reg1, reg2 |
| JNE | 0 | `10 REG` | jump if EQUAL (inverted!) |

## Exploit Strategy for AWD

### Information Disclosure (Oracle)
```python
# Leak byte at VM address using oracle
def leak_byte(vm_addr):
    val = 0
    for bit in range(32):
        # For each bit, run VM code that:
        # 1. Sets SP to vm_addr - 4
        # 2. POP reg0 (loads [vm_addr])
        # 3. SHL reg0, 31-bit
        # 4. SHR reg0, 31
        # 5. CMP reg0, expected_bit
        # 6. JNE to HLT
        # 7. ILLEGAL (if not equal)
        # 8. HLT (if equal)
        if "TERMINATED" in output:
            val |= (1 << bit)
    return val
```

### For Flag Exfiltration
If the flag is placed in VM memory by the challenge infrastructure:
1. Determine where flag is loaded (common addresses: 0x0, 0x1000, etc.)
2. Use oracle to leak flag byte by byte

### For RCE (Not Found)
No clear path to RCE was discovered. The OOB write is within usable malloc area.

## Files Created

- `final_exploit.py` - **MAIN EXPLOIT** - Demonstrates UAF + Oracle
- `working_exploit.py` - Early oracle demonstration
- `*.py` - Various exploration attempts

## Running the Exploit

```bash
# Local test
python3 final_exploit.py

# Remote (replace with actual AWD target)
python3 final_exploit.py HOST:9999
```

## Defense Patches (AWD)

To patch for defense:
1. **Fix UAF:** Don't free pages that are still mapped in page table
2. **Limit instruction execution:** Already has 511 limit, consider lower
3. **Add delay/rate limiting:** Slow down oracle attacks
4. **Randomize page allocation:** Make heap layout less predictable
5. **Validate SP offsets:** Check for offset > 0xFC in PUSH/POP

## Next Steps for RCE

The UAF provides a path to potential RCE:
1. Free a page → goes to tcache
2. Corrupt tcache fd pointer (need to find a way)
3. Allocate new page → returns arbitrary address
4. Write to that address → arbitrary write
5. Overwrite GOT or return address → RCE

The challenge is corrupting the tcache fd pointer. Possible approaches:
- Find a heap overflow we missed
- Use partial overwrite if ASLR is weak
- Chain multiple UAFs

