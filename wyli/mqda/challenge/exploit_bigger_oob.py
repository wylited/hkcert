#!/usr/bin/env python3
"""
Try to write at higher offsets.

PUSH writes at page_data[offset + 4] where offset = SP & 0xFF
Maximum offset = 0xFF + 4 = 0x103

To reach offset 0x108, we'd need SP & 0xFF = 0x104, which is impossible (max 255).

BUT! What if the SP is a full 32-bit value that wraps around strangely?

After PUSH, SP -= 4. If we can make SP have 0xFF low byte before a PUSH...

SP = something with low byte 0xFF
PUSH writes at offset 0xFF + 4 = 0x103
SP -= 4 -> low byte becomes 0xFB

Can we get higher? The issue is the +4 caps at 0x103.

Wait - what about POP? Let me check POP offset calculation.
"""
from pwn import *

context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def hlt():
    return bytes([0x00])

# Check if POP can read from higher offsets
# POP: reads from [SP+4], then SP += 4

# If SP low byte = 0xFF, read from offset 0x103
# After POP, SP += 4 -> low byte = 0x03 (wrapped)

# If we want higher OOB read:
# We need get_page to return one page but offset to point into next chunk

# Wait - let me understand the allocation pattern:
# Pages are allocated as needed via get_page()
# get_page(addr) allocates a page for (addr >> 8) 
# The page covers offsets 0-255

# If stack is at 0x20000, that's page 0x200
# After push at 0x20000, SP = 0x1FFFC
# That's page 0x1FF, offset 0xFC
# Push writes at 0x1FF page, offset 0xFC+4 = 0x100

# Each page is independent. The OOB write goes into whatever is NEXT to page 0x1FF

# The key insight: we control when pages get allocated!
# If we allocate pages in a specific order, we might be able to control what's adjacent

print("[*] Let's trace exactly what gets allocated")
print("[*] 1. Code at 0x10000 -> allocates page 0x100")
print("[*] 2. Stack at 0x20000 -> allocates page 0x200")
print("[*] 3. After first PUSH, SP = 0x1FFFC -> page 0x1FF, offset 0xFC")
print("[*] 4. Second PUSH writes at page 0x1FF offset 0x100 - OOB!")
print("[*] 5. But page 0x1FF might be freshly allocated, so next chunk is...")
print("[*]    It depends on heap state!")

# Let me check if we can do STORE at offset 0x100+
# STORE uses register value as address
# If reg = some address with offset >= 0x100, can we write OOB?

print("\n[*] STORE instruction: writes at reg value")
print("[*] Let's try STORE with address 0x20100 (page 0x201, offset 0x00)")
print("[*] That would require page 0x201 to exist")

# Actually let's test what happens with STORE at various offsets
