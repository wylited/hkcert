#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'warning'

# VM instruction encoders
def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jmp_reg(reg):
    """Opcode 14: unconditional jump to reg"""
    return bytes([0x0e, reg])

def jne_reg(reg):
    """Opcode 16: jump if NOT equal (flags & 2 != 0) - BUT inverted!"""
    return bytes([0x10, reg])

def je_reg(reg):
    """Opcode 15: jump if equal (flags & 3 != 0) - BUT inverted!"""
    return bytes([0x0f, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_test_code(expected_value, use_jne=True):
    """
    Create code that tests if r0 equals expected_value.
    Due to inverted semantics:
    - JNE jumps when flags & 2 == 0 (so when equal or less/greater)
    - JE jumps when flags & 3 == 0 (so when NOT equal and NOT less/greater)
    
    Actually let me re-analyze...
    """
    code = b''
    
    # mov r15, 0
    code += mov_reg_imm(15, 0)
    
    # pop r0 (reads first 4 bytes of our code)
    code += pop_reg(0)
    
    # mov r1, expected_value
    code += mov_reg_imm(1, expected_value)
    
    # cmp r0, r1
    code += cmp_reg_reg(0, 1)
    
    # For JE/JNE, we need to understand the flag logic:
    # After CMP, if values are equal: flags bit 0 = 1 (equal)
    # JE checks: if flags & 3 != 0, DON'T jump; else jump
    # So JE jumps only if flags & 3 == 0 (neither equal nor something else)
    # 
    # JNE checks: if flags & 2 != 0, DON'T jump; else jump
    # flags bit 1 might be set for less-than?
    
    # Let me try: if EQUAL, flags = 1 (bit 0 set)
    # JNE: flags & 2 = 0, so it WILL jump
    # JE: flags & 3 = 1 != 0, so it WON'T jump
    
    # So to jump on EQUAL, use JNE!
    
    # Calculate HLT offset
    current = len(code)  # After cmp
    # Next: mov r2, offset (6) + jne/je (2) + illegal (1) + hlt (1)
    hlt_offset = current + 6 + 2 + 1
    
    # mov r2, hlt_offset
    code += mov_reg_imm(2, hlt_offset)
    
    if use_jne:
        code += jne_reg(2)  # Jump to HLT if equal
    else:
        code += je_reg(2)   # Jump to HLT if NOT equal
    
    # Illegal (reached if NOT equal when using JNE)
    code += trigger_illegal()
    
    # HLT (reached if equal when using JNE)
    code += hlt()
    
    return code

def run_test(code, desc):
    p = process(['./mqda'], level='error')
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    result = "TERMINATED" if b'TERMINATED' in output else ("ILLEGAL" if b'ILLEGAL' in output else "UNKNOWN")
    print(f"{desc}: {result}")
    return result

def main():
    # First dword of code will be 0x00000f41 (mov r15, 0 instruction)
    correct_value = 0x00000f41
    wrong_value = 0xDEADBEEF
    
    print("Testing JNE behavior:")
    # Test 1: Compare with correct value, use JNE
    code1 = create_test_code(correct_value, use_jne=True)
    run_test(code1, f"  JNE, compare 0x{correct_value:08x} (should be TERMINATED)")
    
    # Test 2: Compare with wrong value, use JNE  
    code2 = create_test_code(wrong_value, use_jne=True)
    run_test(code2, f"  JNE, compare 0x{wrong_value:08x} (should be ILLEGAL)")
    
    print("\nTesting JE behavior:")
    # Test 3: Compare with correct value, use JE
    code3 = create_test_code(correct_value, use_jne=False)
    run_test(code3, f"  JE, compare 0x{correct_value:08x} (should be ILLEGAL)")
    
    # Test 4: Compare with wrong value, use JE
    code4 = create_test_code(wrong_value, use_jne=False)
    run_test(code4, f"  JE, compare 0x{wrong_value:08x} (should be TERMINATED)")

if __name__ == '__main__':
    main()
