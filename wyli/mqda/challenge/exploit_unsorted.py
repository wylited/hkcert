#!/usr/bin/env python3
"""
Exploit: Try to get a chunk into unsorted bin

If we can free enough chunks to overflow tcache, they go into unsorted bin.
Unsorted bin has libc pointers we can leak!

Tcache holds 7 entries per size. If we free 8+ chunks of same size,
the 8th goes into unsorted bin.

But: cleanup only frees pages with all-zero data. We can't easily zero pages.
"""
from pwn import *

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def main():
    # To zero a page, we need to write 0 to all 256 bytes
    # That's 64 PUSH instructions (each writes 4 bytes)
    # But PUSH writes to SP, not absolute address
    # So for each page, we need 64 instructions
    
    # To free 8 pages: 8 * 64 = 512 instructions > limit!
    # We can't free enough pages to overflow tcache.
    
    # Alternative: create code that zeros itself after running
    # No, that's not how it works either.
    
    # Let me check if there's a more efficient way to write zeros...
    
    # Actually, STORE instruction exists!
    # STORE [reg], reg - writes reg value to [reg] address
    
    print("[*] Checking STORE opcode for efficient zeroing...")
    
    # STORE opcode is 7
    # mode 1: STORE [reg1], reg2 = 3 bytes
    # If we use a loop, we might be able to zero pages efficiently
    
    # But loops require conditional jumps based on comparison
    # Let's see how many instructions it takes...
    
    # For zeroing 256 bytes:
    # - Set r0 = 0
    # - For i in 0..63:
    #   - STORE [addr + i*4], r0
    # That's 64 STORE instructions per page
    
    # Still too many. We can't zero 8 pages within 511 instructions.
    
    print("[!] Cannot free enough pages to overflow tcache within instruction limit")

if __name__ == '__main__':
    main()
