#!/usr/bin/env python3
"""
MQDA Exploit - Simple Oracle Test

Let's write a known value and then read it back to verify the oracle works.
"""
from pwn import *

context.arch = 'amd64'
context.log_level = 'error'

def hlt():
    return bytes([0x00])

def mov_reg_imm(reg, imm32):
    return bytes([0x41, reg]) + p32(imm32)

def push_reg(reg):
    return bytes([0x02, reg])

def pop_reg(reg):
    return bytes([0x03, reg])

def shl_reg_imm(reg, imm32):
    return bytes([0x4b, reg]) + p32(imm32)

def shr_reg_imm(reg, imm32):
    return bytes([0x4c, reg]) + p32(imm32)

def cmp_reg_reg(reg1, reg2):
    return bytes([0x2d, reg1, reg2])

def jne_reg(reg):
    return bytes([0x10, reg])

def trigger_illegal():
    return bytes([0xFF])

def test_known_value():
    """
    Write 0xDEADBEEF to a known location, then read it back and compare.
    """
    code_addr = 0x10000
    data_addr = 0x20004  # Page 0x200, offset 4
    test_value = 0xDEADBEEF
    
    code = b''
    
    # Write test_value to data_addr via PUSH
    # SP must be data_addr - 4 for PUSH to write at [SP+4] = data_addr
    # PUSH writes at page[offset+4] where page = SP >> 8, offset = SP & 0xFF
    # We want page = 0x200, offset = 0 -> [0+4] = offset 4 in page 0x200
    # So SP = 0x20000
    code += mov_reg_imm(15, 0x20000)  # SP = 0x20000
    code += mov_reg_imm(0, test_value)
    code += push_reg(0)  # Writes at page[4], SP becomes 0x1FFFC
    
    # Now read it back via POP
    # POP reads from [SP+4] where page = SP >> 8, offset = SP & 0xFF
    # We want to read from page 0x200, offset 4
    # [SP+4] means page[(SP&0xFF)+4]
    # Need (SP&0xFF)+4 = 4, so (SP&0xFF) = 0
    # And SP >> 8 = 0x200
    # So SP = 0x20000
    code += mov_reg_imm(15, 0x20000)
    code += pop_reg(1)  # r1 = [0x20000 + 4] = page[4] = test_value
    
    # Compare r1 to test_value
    code += mov_reg_imm(2, test_value)
    code += cmp_reg_reg(1, 2)
    
    # JNE jumps when EQUAL
    current = code_addr + len(code)
    success_addr = current + 6 + 2 + 1
    code += mov_reg_imm(3, success_addr)
    code += jne_reg(3)
    code += trigger_illegal()  # Not equal
    code += hlt()  # Equal - success!
    
    print(f"[*] Code length: {len(code)}")
    print(f"[*] Test value: 0x{test_value:08x}")
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    print(f"[*] Output: {output}")
    
    if b'TERMINATED' in output:
        print("[+] SUCCESS! Read back 0xDEADBEEF correctly!")
        return True
    else:
        print("[-] FAILED to read back value")
        return False

def test_bit_oracle():
    """Test the bit-by-bit oracle by checking known bits of a known value."""
    code_addr = 0x10000
    
    # Test value 0x42 = 0b01000010
    # Bits: 1 at positions 1 and 6
    
    test_value = 0x42
    bit_pos = 1  # Should be 1
    expected = 1
    
    code = b''
    
    # Write test_value
    code += mov_reg_imm(15, 0x20000)
    code += mov_reg_imm(0, test_value)
    code += push_reg(0)
    
    # Read it back
    code += mov_reg_imm(15, 0x20000)
    code += pop_reg(0)
    
    # Isolate bit 1: shift left 30, shift right 31
    code += shl_reg_imm(0, 30)
    code += shr_reg_imm(0, 31)
    
    # r0 should now be 1
    code += mov_reg_imm(1, expected)
    code += cmp_reg_reg(0, 1)
    
    current = code_addr + len(code)
    success_addr = current + 6 + 2 + 1
    code += mov_reg_imm(2, success_addr)
    code += jne_reg(2)
    code += trigger_illegal()
    code += hlt()
    
    print(f"\n[*] Testing bit {bit_pos} of 0x{test_value:02x} (expect {expected})...")
    
    p = process(['./mqda'])
    p.recvuntil(b'Code Address> ')
    p.sendline(str(code_addr).encode())
    p.recvuntil(b'Code Length> ')
    p.sendline(str(len(code)).encode())
    p.recvuntil(b'Code> ')
    p.send(code)
    p.recvuntil(b'Entry IP> ')
    p.sendline(str(code_addr).encode())
    
    output = p.recvall(timeout=2)
    print(f"[*] Output: {output}")
    
    if b'TERMINATED' in output:
        print("[+] Bit oracle WORKS!")
        return True
    else:
        print("[-] Bit oracle failed")
        return False

if __name__ == '__main__':
    test_known_value()
    test_bit_oracle()
